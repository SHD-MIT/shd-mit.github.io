<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2025/assets/css/just-the-docs-default.css"> <script src="/2025/assets/js/vendor/lunr.min.js"></script> <script src="/2025/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>ASLR Bypasses | 6.5950/6.5951</title> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="ASLR Bypasses" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Secure Hardware Design" /> <meta property="og:description" content="Secure Hardware Design" /> <meta property="og:site_name" content="6.5950/6.5951" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="ASLR Bypasses" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Secure Hardware Design","headline":"ASLR Bypasses","url":"/2025/labs/aslr.html"}</script> <!-- End Jekyll SEO tag --> <!-- Cover up the page while CSS is loading to prevent flicker --> <div id="preload-cover"></div> <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" /> <style> #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#fff; z-index:9999; } @media (prefers-color-scheme: dark) { #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#222326; z-index:9999; } } </style> <script> window.addEventListener('load', function() { var cover = document.getElementById('preload-cover'); cover.style.display = 'none'; }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Feather. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/2025/" class="site-title lh-tight"> 6.5950/6.5951 </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/2025/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2025/calendar.html" class="nav-list-link">Calendar</a></li><li class="nav-list-item"><a href="/2025/lectureReadings.html" class="nav-list-link">Lecture Readings</a></li><li class="nav-list-item"><a href="/2025/paperDiscussion.html" class="nav-list-link">Paper Discussion</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Recitations category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2025/recitations.html" class="nav-list-link">Recitations</a><ul class="nav-list "><li class="nav-list-item "><a href="/2025/recitations/cpp.html" class="nav-list-link">CTF of C Programming</a></li><li class="nav-list-item "><a href="/2025/recitations/cache.html" class="nav-list-link">Cache Recitation</a></li><li class="nav-list-item "><a href="/2025/recitations/physical.html" class="nav-list-link">CTF of Physical Attacks</a></li><li class="nav-list-item "><a href="/2025/recitations/riscv.html" class="nav-list-link">Binary Exploitation and RISC-V Warmup</a></li><li class="nav-list-item "><a href="/2025/recitations/formal.html" class="nav-list-link">Formal Verification</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2025/labs.html" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item "><a href="/2025/labs/ccc.html" class="nav-list-link">C Crash Course</a></li><li class="nav-list-item "><a href="/2025/labs/fingerprinting.html" class="nav-list-link">Website Fingerprinting</a></li><li class="nav-list-item "><a href="/2025/labs/cache.html" class="nav-list-link">Cache Attacks</a></li><li class="nav-list-item "><a href="/2025/labs/spectre.html" class="nav-list-link">Spectre Attacks</a></li><li class="nav-list-item "><a href="/2025/labs/rowhammer.html" class="nav-list-link">Rowhammer</a></li><li class="nav-list-item active"><a href="/2025/labs/aslr.html" class="nav-list-link active">ASLR Bypasses</a></li><li class="nav-list-item "><a href="/2025/labs/psp.html" class="nav-list-link">Pretty Secure Processor</a></li><li class="nav-list-item "><a href="/2025/labs/fuzz.html" class="nav-list-link">CPU Fuzzing</a></li><li class="nav-list-item "><a href="/2025/labs/formal.html" class="nav-list-link">CPU Verification</a></li></ul></li><li class="nav-list-item"><a href="/2025/paperReadingGuidance.html" class="nav-list-link">Paper Readings Guidance</a></li><li class="nav-list-item"><a href="/2025/forInstructors.html" class="nav-list-link">For Instructors</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search 6.5950/6.5951" aria-label="Search 6.5950/6.5951" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <span id="dark-light-switch" class="material-symbols-outlined"></span> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/2025/labs.html">Labs</a></li> <li class="breadcrumb-nav-list-item"><span>ASLR Bypasses</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <script> function ColorCorrect() { const theme = jtd.getTheme(); if (theme == "dark") { document.getElementById("figure1-light").style = "display: none;"; } else { document.getElementById("figure1-dark").style = "display: none;"; } } document.addEventListener('DOMContentLoaded', function () { ColorCorrect(); }, false); </script> <style> td { font-size: large !important; } </style> <h1 class="no_toc" id="aslr-bypasses-lab"> <a href="#aslr-bypasses-lab" class="anchor-heading" aria-labelledby="aslr-bypasses-lab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ASLR Bypasses Lab </h1> <p><strong>Due Date: Apr 17</strong>; Last Updated Date: Jan 14</p> <h2 class="no_toc text-delta" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of contents </h2> <ul id="markdown-toc"> <li><a href="#background" id="markdown-toc-background">Background</a></li> <li><a href="#part-1-breaking-aslr" id="markdown-toc-part-1-breaking-aslr">Part 1: Breaking ASLR</a> <ul> <li><a href="#part-1a-egghunter-15" id="markdown-toc-part-1a-egghunter-15">Part 1A: Egghunter (15%)</a></li> <li><a href="#part-1b-prefetch-side-channels-40" id="markdown-toc-part-1b-prefetch-side-channels-40">Part 1B: Prefetch Side Channels (40%)</a></li> <li><a href="#part-1c-speculative-probing-5" id="markdown-toc-part-1c-speculative-probing-5">Part 1C: Speculative Probing (5%)</a></li> </ul> </li> <li><a href="#part-2-code-reuse-attacks" id="markdown-toc-part-2-code-reuse-attacks">Part 2: Code Reuse Attacks</a> <ul> <li><a href="#part-2a-ret2win-10" id="markdown-toc-part-2a-ret2win-10">Part 2A: <code class="language-plaintext highlighter-rouge">ret2win</code> (10%)</a></li> <li><a href="#part-2b-return-oriented-programming-rop-20" id="markdown-toc-part-2b-return-oriented-programming-rop-20">Part 2B: Return Oriented Programming (ROP) (20%)</a></li> </ul> </li> <li><a href="#part-3-putting-it-all-together-10" id="markdown-toc-part-3-putting-it-all-together-10">Part 3: Putting it All Together (10%)</a></li> <li><a href="#references" id="markdown-toc-references">References</a></li> </ul> <h3 class="no_toc" id="collaboration-policy"> <a href="#collaboration-policy" class="anchor-heading" aria-labelledby="collaboration-policy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Collaboration Policy </h3> <p>Our full Academic Honesty policy can be found on the <a href="../index.html#collaboration-policy">Course Information page</a> of our website. As a reminder, all 6.5950/6.5951 labs should be completed individually. You may discuss the lab at a high level with a classmate, but you may not work on code together or share any of your code.</p> <h2 class="no_toc" id="getting-started"> <a href="#getting-started" class="anchor-heading" aria-labelledby="getting-started"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h2> <p>This lab will be done on the same machine and user account as the Spectre lab, using one of the <code class="language-plaintext highlighter-rouge">arch-sec-[2,4].csail.mit.edu</code> as we have emailed you for the Spectre lab. We will not email you again about this information but feel free to ask TA if you forget it.</p> <p>We are using <code class="language-plaintext highlighter-rouge">git</code> for all the labs – instructions for setting up the git repository can be found on the <a href="../labs.html#github">labs page</a>.</p> <p>In addition to submitting code, you are required to submit a PDF lab report containing your answers to Discussion Questions to <a href="https://www.gradescope.com/courses/965204">Gradescope</a>. We provide a markdown template in the starter code (<code class="language-plaintext highlighter-rouge">report.md</code>).</p> <h2 id="background"> <a href="#background" class="anchor-heading" aria-labelledby="background"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Background </h2> <p>Long, long ago, programs used to be loaded at constant addresses. Every time you ran a program, every function was located at the exact same virtual address. This made it quite easy for attackers to jump to known locations in program memory as part of their exploits, as they knew that specific functions would be located at specific addresses every time.</p> <p>Enter <strong>Address-Space Layout Randomization</strong>, or <strong>ASLR</strong>. This mitigation randomizes the address of the program at runtime so that attackers can’t simply know the actual addresses of payloads or gadgets. It is now a necessity for most memory corruption exploits to first break the ASLR, meaning the attackers need to know how ASLR maps each constant address to a new random address. We will explore several means of breaking ASLR using, you guessed it, microarchitectural side channels.</p> <p>Luckily for us attackers, ASLR in Linux is applied not at the byte or word level, but at a page granularity. This means that on our <code class="language-plaintext highlighter-rouge">x86_64</code> machines with 4KB pages, the lower 12 bits of an address will always stay the same (as only the virtual page number changes from run to run).</p> <p>ASLR is applied as a random constant, let’s call it delta, added to every virtual page number in the program’s address space. People usually use different delta values for different parts of memory. (So the stack gets its own delta, the heap gets its own delta, and the program code gets its own delta).</p> <p>This means that relative distances within a region are preserved under ASLR – Leaking just one pointer to a given region is typically sufficient to find anything in that region. For example, if my program binary has two methods- <code class="language-plaintext highlighter-rouge">MethodA</code> and <code class="language-plaintext highlighter-rouge">MethodB</code>, knowing the address of <code class="language-plaintext highlighter-rouge">MethodA</code> tells me where to find <code class="language-plaintext highlighter-rouge">MethodB</code>. The relative distance between <code class="language-plaintext highlighter-rouge">MethodA</code> and <code class="language-plaintext highlighter-rouge">MethodB</code> is unchanged under ASLR. As such, attackers only need to find the address for one of these addresses. We declare ASLR defeated if we can leak just a single address.</p> <p>In this lab, we will explore ASLR from a hardware perspective, and investigate techniques that can be used to reveal the address space layout by creating our own microarchitectural infoleaks.</p> <h3 class="no_toc" id="lab-codebase"> <a href="#lab-codebase" class="anchor-heading" aria-labelledby="lab-codebase"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lab Codebase </h3> <p>This lab is divided into three distinct modules – parts 1, 2, and 3. The code for each is contained within the <code class="language-plaintext highlighter-rouge">part1</code>, <code class="language-plaintext highlighter-rouge">part2</code>, and <code class="language-plaintext highlighter-rouge">part3</code> folders respectively.</p> <p>In Part 1, you will be modifying the files <code class="language-plaintext highlighter-rouge">part1A.c</code>, <code class="language-plaintext highlighter-rouge">part1B.c</code>, and <code class="language-plaintext highlighter-rouge">part1C.c</code>. You should not modify <code class="language-plaintext highlighter-rouge">main.c</code>.</p> <p>In Part 2, you will be modifying <code class="language-plaintext highlighter-rouge">part2A.c</code> and <code class="language-plaintext highlighter-rouge">part2B.c</code>. The vulnerable method you will be exploiting is defined in <code class="language-plaintext highlighter-rouge">main.c</code>. The <code class="language-plaintext highlighter-rouge">win</code> and <code class="language-plaintext highlighter-rouge">call_me_maybe</code> methods are also defined in <code class="language-plaintext highlighter-rouge">main.c</code>. The gadgets to use for your ROP chain are defined in <code class="language-plaintext highlighter-rouge">gadgets.s</code>. You should not modify <code class="language-plaintext highlighter-rouge">main.c</code>.</p> <p>In Part 3, you will be modifying <code class="language-plaintext highlighter-rouge">part3.c</code>. Just like in Part 2, <code class="language-plaintext highlighter-rouge">call_me_maybe</code> and <code class="language-plaintext highlighter-rouge">vulnerable</code> are defined in <code class="language-plaintext highlighter-rouge">main.c</code>. The gadgets you will be using are in <code class="language-plaintext highlighter-rouge">gadgets.o</code> (run <code class="language-plaintext highlighter-rouge">make</code> to get it), and are the same as the gadgets in <code class="language-plaintext highlighter-rouge">part2/gadgets.s</code>. You should not modify <code class="language-plaintext highlighter-rouge">main.c</code>.</p> <p>For all three parts, you will build the lab by running <code class="language-plaintext highlighter-rouge">make</code>. Each subpart is a binary identified simply by the part letter. For example, Part 2 will contain:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a  b  build  gadgets.s  main.c  Makefile  part2A.c  part2B.c
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are your built programs. (<code class="language-plaintext highlighter-rouge">a</code> is your solution for Part 2A and <code class="language-plaintext highlighter-rouge">b</code> is your solution for Part 2B). You can run them with <code class="language-plaintext highlighter-rouge">./a</code> or <code class="language-plaintext highlighter-rouge">./b</code>.</p> <p>In Part 3, the binary is simply called <code class="language-plaintext highlighter-rouge">part3</code>, as there is only one subsection for Part 3.</p> <p>Here’s a list of all files we will consider while grading:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- part1/part1A.c
- part1/part1B.c
- part1/part1C.c
- part2/part2A.c
- part2/part2B.c
- part3/part3.c
</code></pre></div></div> <p>You are free to include whatever standard library header files you’d like anywhere in the lab. If you accidentally include something that uses an illegal syscall, you’ll see the <code class="language-plaintext highlighter-rouge">seccomp-filter</code> complain (See the section about the <a href="#jailing">ASLR lab jail</a>).</p> <h3 class="no_toc" id="automated-checking"> <a href="#automated-checking" class="anchor-heading" aria-labelledby="automated-checking"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Automated Checking </h3> <p>We provide a check script that can tell you whether your code was correct or not. The script is very similar to the autograder we used in the spectre lab.</p> <p>Below are the options available with the check utility:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> % ./check.py <span class="nt">-h</span>
usage: check.py <span class="o">[</span><span class="nt">-h</span><span class="o">]</span> part

Check your lab code

positional arguments:
  part        Which part to check? 1a, 1b, 1c, 2a, 2b, or 3?

optional arguments:
  <span class="nt">-h</span>, <span class="nt">--help</span>  show this <span class="nb">help </span>message and <span class="nb">exit</span>
</code></pre></div></div> <p>You can check a specific part by specifying the part to check:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> % ./check.py 1a
make: Nothing to be <span class="k">done for</span> <span class="s1">'all'</span><span class="nb">.</span>
Checking part 1A...
100%|██████████████████████████████████████████████████████████| 100/100 <span class="o">[</span>00:00&lt;00:00, 500.13it/s]
You passed 100 of 100 runs <span class="o">(</span>100.0%<span class="o">)</span>
Success! Good job

Your score is 20 / 20
You scored 100.0% <span class="k">for </span>this part!
</code></pre></div></div> <p>You can also check the entire lab by running <code class="language-plaintext highlighter-rouge">./check.py all</code>. At the end the autograder will tell you your grade. In the above example, we scored 100% for Part 1A.</p> <h3 class="no_toc" id="jailing"> <a href="#jailing" class="anchor-heading" aria-labelledby="jailing"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Jailing </h3> <p>During these exercises, you will be operating inside of a <code class="language-plaintext highlighter-rouge">chroot</code> and <code class="language-plaintext highlighter-rouge">seccomp-filter</code> jail. This jail will prevent your code from performing most system calls and file accesses, so you can’t simply read <code class="language-plaintext highlighter-rouge">/proc/self/pagemap</code> to determine where our mystery page is.</p> <p>Here’s the system calls that we allow your code to execute:</p> <div class="table-wrapper"><table> <tbody> <tr> <td><strong>Allowed Syscalls in this lab</strong></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">write</code>- Write to an already opened file descriptor.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">access</code>- See Part 1A.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">close</code>- Close a file descriptor.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">exit</code> / <code class="language-plaintext highlighter-rouge">exit_group</code> - Quit the program.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">fstat</code>- Needed by <code class="language-plaintext highlighter-rouge">printf</code>.</td> </tr> </tbody> </table></div> <p>If your code tries to access an illegal syscall, you’ll see the following message:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> % ./part1A
zsh: invalid system call  ./part1A
</code></pre></div></div> <p>You can use <code class="language-plaintext highlighter-rouge">strace</code> to trace which system calls your program made.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> % strace ./part1A
...
execve<span class="o">(</span>NULL, NULL, NULL<span class="o">)</span>                <span class="o">=</span> ?
+++ killed by SIGSYS +++
zsh: invalid system call  strace ./part1A
</code></pre></div></div> <p>In this example, the program was terminated for trying to use <code class="language-plaintext highlighter-rouge">execve</code>.</p> <p>You should not have to worry about the filter, as it is only there to prevent you from bypassing the lab assignment in a trivial manner, and to increase the immersion of the lab experience.</p> <p>If you’re curious about how the <code class="language-plaintext highlighter-rouge">seccomp</code> filter works, check out <code class="language-plaintext highlighter-rouge">setup_jail</code> in <code class="language-plaintext highlighter-rouge">main.c</code> of Part 1 or 3 (Part 2 doesn’t use a jail).</p> <h2 id="part-1-breaking-aslr"> <a href="#part-1-breaking-aslr" class="anchor-heading" aria-labelledby="part-1-breaking-aslr"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1: Breaking ASLR </h2> <p>In this part we will explore three different ways to break ASLR – one simple method operating at the ISA level, and two of them relying on microarchitectural attacks.</p> <p>In all three parts, you will be tasked with locating a single page of code within a given range. Before your code runs, we will <code class="language-plaintext highlighter-rouge">mmap</code> a random page into memory at a random location within this range. Everywhere inside this range except for the single page to find will be unmapped (no entry in the page table). We will then pass the range (the upper bound and the lower bound) to your code. You will scan this range using three different techniques, and return the correct page as the return value of your function. See the figure below.</p> <p><img src="figures/aslr_part1_light.png" id="figure1-light" /> <img src="figures/aslr_part1_dark.png" id="figure1-dark" /></p> <p>Your code will operate as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Your code for each exercise in Part 1:</span>
<span class="kt">uint64_t</span> <span class="nf">find_address</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">low</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// The implementation of is_the_page_mapped will be</span>
        <span class="c1">// different for Parts 1A, 1B, and 1C.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_the_page_mapped</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>For now, all you need to do is locate the page. In later parts, we’ll need the location of this page for conducting realistic code reuse attacks in Part 3!</p> <h3 id="part-1a-egghunter-15"> <a href="#part-1a-egghunter-15" class="anchor-heading" aria-labelledby="part-1a-egghunter-15"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1A: Egghunter (15%) </h3> <p>Egghunters are a technique commonly used in binary exploitation where you have limited code execution and are trying to find a larger payload to execute. For example, you may be able to execute a small (on the order of 64 bytes) amount of code. You have also injected a larger code payload into the program but don’t know where it is located. An “egg hunter” is a small chunk of code that is used to find the larger chunk of code.</p> <p>In this lab, we will be writing an egg hunter in C to scan for a page in memory. We won’t be looking for a particular value in memory (as most egg hunters do) – we will just look for the mapped page.</p> <p>You may be wondering what the mechanism for egg hunting actually is. Typically, it is the kernel itself! To see what we mean by this, check out this excerpt from the <code class="language-plaintext highlighter-rouge">man</code> page for the <a href="https://man7.org/linux/man-pages/man2/access.2.html"><code class="language-plaintext highlighter-rouge">access</code> system call</a>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERRORS

       EACCES The requested access would be denied to the file, or
              search permission is denied for one of the directories in
              the path prefix of pathname.  (See also
              path_resolution(7).)

       ...

       EFAULT pathname points outside your accessible address space.

       ...
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">access</code> syscall takes a path name and a mode, and returns whether the file can be accessed by our current process. It has the following declaration:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">access</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div></div> <p>We provide <code class="language-plaintext highlighter-rouge">access</code> a pointer to a string containing the path name, and it will do something with it (what it does, we don’t care). We won’t be using <code class="language-plaintext highlighter-rouge">access</code> for its intended purpose – we will use it as an oracle for determining if an address is mapped into our address space.</p> <p>Notice how <code class="language-plaintext highlighter-rouge">access</code> will return the <code class="language-plaintext highlighter-rouge">EACCES</code> error if the string points to valid memory (but describes an invalid file), and the <code class="language-plaintext highlighter-rouge">EFAULT</code> error if the string we provide doesn’t belong to our address space. We can pass every address in the region to scan to <code class="language-plaintext highlighter-rouge">access</code>, and if <code class="language-plaintext highlighter-rouge">access</code> returns anything but <code class="language-plaintext highlighter-rouge">EFAULT</code>, we know the address is mapped!</p> <blockquote class="hint-title"> <p>Key Idea</p> <p>If <code class="language-plaintext highlighter-rouge">access</code> returns <code class="language-plaintext highlighter-rouge">EFAULT</code>, our argument to <code class="language-plaintext highlighter-rouge">pathname</code> was unmapped.</p> </blockquote> <blockquote class="exercise-title"> <p>1-1 Exercise</p> <p>Implement an egg hunter using the <a href="https://man7.org/linux/man-pages/man2/access.2.html"><code class="language-plaintext highlighter-rouge">access</code></a> system call.</p> </blockquote> <blockquote class="hint"> <p>Any error generated by a call to <code class="language-plaintext highlighter-rouge">access</code> isn’t directly returned by the function itself, see the “Return Value” section of the <a href="https://man7.org/linux/man-pages/man2/access.2.html"><code class="language-plaintext highlighter-rouge">access</code> man-page</a> for more details.</p> </blockquote> <blockquote class="discussion-title"> <p>1-2 Discussion Question</p> <p>Identify one other <a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">syscall</a> that could be used for egg hunting.</p> </blockquote> <blockquote class="hint"> <p>Any syscall that returns <code class="language-plaintext highlighter-rouge">EFAULT</code> is likely to be useful for egg hunting.</p> <p>Sadly, while this approach works great for userspace, it won’t work on kernel addresses becuase no matter whether a kernel address is mapped or not, your <code class="language-plaintext highlighter-rouge">access</code> from userspace will always say the kernel address cannot be accessed. For that, we need to move to the microarchitectural level. (Parts 1B and 1C are done in userspace, but the techniques have been shown to work on the kernel as well).</p> </blockquote> <h3 class="no_toc" id="grading"> <a href="#grading" class="anchor-heading" aria-labelledby="grading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading </h3> <p>Each attempt (i.e., each run of <code class="language-plaintext highlighter-rouge">./part1/a</code>) should run in <strong>1 second or less</strong> and should produce the correct answer 100% of the time. (If it ever gets the answer wrong, you will receive a 0 for this part).</p> <h3 id="part-1b-prefetch-side-channels-40"> <a href="#part-1b-prefetch-side-channels-40" class="anchor-heading" aria-labelledby="part-1b-prefetch-side-channels-40"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1B: Prefetch Side Channels (40%) </h3> <p>In this part, we will be implementing the Prefetch attack from <em>Prefetch Side-Channel Attacks</em> [1].</p> <p>The <a href="https://c9x.me/x86/html/file_module_x86_id_252.html"><code class="language-plaintext highlighter-rouge">prefetch</code></a> instruction provides a hint to the hardware prefetcher to load a particular line into the cache. This instruction performs absolutely 0 access control checks. We will use the <code class="language-plaintext highlighter-rouge">prefetch</code> instruction to try and load every address into the cache. In particular, we will use the “Translation-Level Oracle” technique (described in their Section 3.2) to locate our hidden page.</p> <p>The <code class="language-plaintext highlighter-rouge">prefetch</code> instruction will try to translate the given virtual address into a physical address and load it into the cache hierarchy. If the address is unmapped, it will require a full page table walk (which takes many cycles!). If the page is already present in the cache hierarchy, <code class="language-plaintext highlighter-rouge">prefetch</code> will finish early.</p> <p>To be more precise, when we use <code class="language-plaintext highlighter-rouge">prefetch</code> on an address, if the corresponding page is unmapped, the page table entry has not appearred in any micro-architectural structures. So the processor ends up doing the following operations:</p> <ol> <li>TLB lookup (miss)</li> <li>Page cache lookup (miss)</li> <li>Page table walk (traverse the page table tree)</li> <li>Find the entry is invalid</li> <li>Done</li> </ol> <p>If the page is mapped and if it has been accessed before, the corresponding page table entry could exist in one or multiple of these structures and <code class="language-plaintext highlighter-rouge">prefetch</code> will finish much earlier.</p> <p>By timing how long <code class="language-plaintext highlighter-rouge">prefetch</code> takes to run, we can determine whether the given address was mapped or not. If <code class="language-plaintext highlighter-rouge">prefetch</code> is slow, that means a full page table walk occurred, and therefore the address was not mapped. If it is fast, that means the address is likely to have already existed in the cache hierarchy, and so is very likely to be our address.</p> <blockquote class="hint-title"> <p>Key Idea</p> <p>Prefetching a mapped address is faster than prefetching unmapped ones.</p> </blockquote> <p>Timing the <code class="language-plaintext highlighter-rouge">prefetch</code> instruction is a little tricky due to CPU synchronization. We recommend you follow the instruction sequence approach used by the paper authors:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mfence
rdtscp
cpuid
prefetch
cpuid
rdtscp
mfence
</code></pre></div></div> <p>While doing this exercise, you may find referring to the <a href="https://github.com/IAIK/prefetch/blob/master/addrspace/addrspace.c">source code for the prefetch paper</a> helpful [3]. You can refer to this repo or past lab assignments for how to write inline assembly. Additionally, <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">the GNU manual</a> on inline assembly is quite handy [9].</p> <p>For causing a <code class="language-plaintext highlighter-rouge">prefetch</code> instruction, you can either try the builtin <code class="language-plaintext highlighter-rouge">_mm_prefetch(address, _MM_HINT_T2)</code> function, or you can use the following wrapper (taken from the IAIK repo [3]):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">prefetch</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"prefetchnta (%0)"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
  <span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span><span class="s">"prefetcht2 (%0)"</span> <span class="o">:</span> <span class="o">:</span> <span class="s">"r"</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <!--*Hint*: You can slow down the page table walk by flushing the cache, forcing the page tables out of the cache, so that the full table walk takes even longer.--> <blockquote class="exercise-title"> <p>1-3 Exercise</p> <p>Use the <code class="language-plaintext highlighter-rouge">prefetch</code> instruction to find the hidden page.</p> </blockquote> <blockquote class="discussion-title"> <p>1-4 Discussion Question</p> <p>Imagine you are the Intel engineer tasked with fixing this problem. How would you approach fixing it?</p> </blockquote> <h3 class="no_toc" id="grading-1"> <a href="#grading-1" class="anchor-heading" aria-labelledby="grading-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading </h3> <p>Each attempt should run in <strong>5 seconds or less</strong> and should produce the correct result 90% of the time or better.</p> <h3 id="part-1c-speculative-probing-5"> <a href="#part-1c-speculative-probing-5" class="anchor-heading" aria-labelledby="part-1c-speculative-probing-5"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1C: Speculative Probing (5%) </h3> <blockquote class="warning"> <p>This part is quite difficult, we suggest finishing the other parts before choosing to do this one!</p> </blockquote> <p>Having access to the <code class="language-plaintext highlighter-rouge">prefetch</code> instruction makes things too easy. Additionally, not all architectures have such a convenient instruction for performing attacks. <strong>Speculative Probing</strong> [2] is a more general technique that has been shown to work on many architectures. We will be implementing a modified version of the Code Region Probing attack described in Section 5.1 of the Speculative Probing paper.</p> <p>To conduct a speculative probing attack, you will write and exploit your <em>own</em> spectre gadget! Here’s an overview of how it works.</p> <p>First, you will write your own Spectre gadget (similar to the one you attacked in the spectre lab). Below is pseudocode you can use as a guide for your speculative probing gadget. Write this as a C function in <code class="language-plaintext highlighter-rouge">part1C.c</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">speculative_probing_gadget</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">controlled_memory</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
        <span class="c1"># Access 1: Derefence the "guess" address (if it is mapped).
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="nf">load</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>

        <span class="c1"># If guess was not mapped, we will crash here.
</span>        <span class="c1"># Hopefully all crashes happen under speculation so the program doesn't crash!
</span>
        <span class="c1"># Access 2: Modify some controlled memory at an index dependent on the first load.
</span>        <span class="c1"># This only happens if the first load didn't crash, since the index is
</span>        <span class="c1"># a function of the contents of the first load.
</span>        <span class="n">controlled_memory</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div> <p>You’ll notice that this gadget operates on a subtly different mechanism than the Spetre gadgets from the spectre lab. In the spectre lab, the goal was to learn the <em>contents</em> of the “guess” address (reveal the contents of the first load). Here, we don’t actually care about the value of the first load. Instead, we only want to determine whether or not the load was <em>successful</em>.</p> <p>There are two cases for our guess address: either our current guess is correct, or it isn’t. If we have the right address, we can read freely from it without any issues. However, if it isn’t mapped, reading from it will cause a page fault exception (that we will observe as a segfault). Just one segfault will crash the whole program. So instead, let’s have the crashes run under speculation, and use a side channel to learn whether or not a crash happened.</p> <blockquote class="hint-title"> <p>Key Idea</p> <p>We suppress exceptions by causing them to happen <em>speculatively</em>, and then afterwords learn whether or not a crash happened using microarchitectural side channels.</p> </blockquote> <p>After creating the gadget, you will need to control it. You can use the following as a high-level overview of a potential attack:</p> <ol> <li>Allocate a chunk of memory to use.</li> <li>Train the branch predictor for your <code class="language-plaintext highlighter-rouge">speculative_probing_gadget</code>.</li> <li>Try an address with <code class="language-plaintext highlighter-rouge">speculative_probing_gadget</code>.</li> <li>Learn whether or not a load occurred with <code class="language-plaintext highlighter-rouge">time_access</code> to your controlled memory.</li> </ol> <p>There are a few engineering problems to solve here. Notably, the contents of the probed memory could be anything! How do you know what <code class="language-plaintext highlighter-rouge">idx</code>’s value was? Is there a way to make our attack access <code class="language-plaintext highlighter-rouge">controlled_memory</code> the same way regardless of what <code class="language-plaintext highlighter-rouge">idx</code> was?</p> <blockquote class="exercise-title"> <p>1-5 Exercise</p> <p>Use speculative probing to leak the address of the hidden page.</p> </blockquote> <ul class="hint"> <li>You completely control the Spectre code, so you can write it any way you like.</li> <li>You may find revisiting the <a href="spectre.html">Spectre lab document</a> or your Spectre lab code helpful.</li> <li>Make sure that both memory accesses happen speculatively so that you don’t crash the program!</li> <li>Don’t forget you can <code class="language-plaintext highlighter-rouge">clflush</code> any address you’d like.</li> </ul> <h3 class="no_toc" id="grading-2"> <a href="#grading-2" class="anchor-heading" aria-labelledby="grading-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading </h3> <p>Each attempt should run in <strong>2 minutes or less</strong> and should produce the correct result 10% of the time or better.</p> <h2 id="part-2-code-reuse-attacks"> <a href="#part-2-code-reuse-attacks" class="anchor-heading" aria-labelledby="part-2-code-reuse-attacks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2: Code Reuse Attacks </h2> <p>In this part, we will explore what the consequences are for breaking ASLR. We will also get some practice constructing realistic code reuse attacks that attackers might use in the real world against vulnerable programs.</p> <p>We will be exploiting a category of bugs known as <strong>buffer overflows</strong>. In a buffer overflow, the program reads more information than can fit into a particular buffer, overwriting memory past the end of the buffer.</p> <h3 class="no_toc" id="buffer-overflows"> <a href="#buffer-overflows" class="anchor-heading" aria-labelledby="buffer-overflows"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Buffer Overflows </h3> <p>The most basic form of a buffer overflow is the <strong>stack buffer overflow</strong>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * vulnerable
 * This method is vulnerable to a buffer overflow
 */</span>
<span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">your_string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate 16 bytes on the stack</span>
    <span class="kt">char</span> <span class="n">stackbuf</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

    <span class="c1">// Copy the attacker-controlled input into 'stackbuf'</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">stackbuf</span><span class="p">,</span> <span class="n">your_string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>If <code class="language-plaintext highlighter-rouge">your_string</code> is larger than 16 bytes, then whatever is on the stack below <code class="language-plaintext highlighter-rouge">stackbuf</code> will be overwritten.</p> <p>So, what’s on the stack?</p> <p>When a function is called, the return address is pushed to the stack. The return address is the next line of code that will be executed. Let’s take a look at a hypothetical piece of assembly:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x100: call vulnerable
0x101: nop
</code></pre></div></div> <p>Immediately after <code class="language-plaintext highlighter-rouge">call vulnerable</code>, the next instruction to execute (in this case, <code class="language-plaintext highlighter-rouge">0x101</code>) will be pushed to the stack. When <code class="language-plaintext highlighter-rouge">vulnerable</code> is done, it will execute <code class="language-plaintext highlighter-rouge">ret</code>, which will pop the return address off the stack and jump to it.</p> <p>Let’s look at the disassembly of <code class="language-plaintext highlighter-rouge">vulnerable</code> to find out more:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vulnerable:
    <span class="c"># rdi contains 'your_string'</span>
    <span class="c"># First, setup the stack frame for vulnerable</span>
1   push   rbp
2   mov    rbp,rsp

    <span class="c"># Create some space for stackbuf on the stack</span>
3   sub    rsp,0x10

    <span class="c"># Put 'your_string' into rsi (argument 2)</span>
4   mov    rsi,rdi

    <span class="c"># Put 'stackbuf' into rdi (argument 1)</span>
5   lea    rax,[rbp-0x10]
6   mov    rdi,rax

    <span class="c"># Call strcpy(stackbuf, your_string)</span>
7   call   strcpy

    <span class="c"># Teardown our stack frame</span>
8   mov rsp, rbp
9   pop rbp

    <span class="c"># Return from vulnerable (this is basically pop rip)</span>
10  ret
</code></pre></div></div> <p>Immediately upon entry to <code class="language-plaintext highlighter-rouge">vulnerable</code> (right before line 1), the stack will look like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Towards 0x0000000000000000

   Stack Growth
       /|\
        |
        |
+---------------+
|     0x101     | &lt;- Return address!
+---------------+

Towards 0xFFFFFFFFFFFFFFFF
</code></pre></div></div> <p>Next, the <code class="language-plaintext highlighter-rouge">rbp</code> register is pushed, and some more space is made for <code class="language-plaintext highlighter-rouge">stackbuf</code>. So, after line 3, the stack will look like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Towards 0x0000000000000000

   Stack Growth
       /|\
        |
        |
+---------------+
|     ?????     | &lt;- Space for stackbuf
+---------------+
|    Old RBP    | &lt;- Saved RBP
+---------------+
|     0x101     | &lt;- Return address!
+---------------+

Towards 0xFFFFFFFFFFFFFFFF
</code></pre></div></div> <p>Note that <code class="language-plaintext highlighter-rouge">stackbuf</code> sits <em>above</em> the return address on the stack. If we put more information into <code class="language-plaintext highlighter-rouge">your_string</code> than can fit into <code class="language-plaintext highlighter-rouge">stackbuf</code>, we will continue writing <em>down</em> the stack, and overwrite the return address! That means we can change what happens when <code class="language-plaintext highlighter-rouge">vulnerable</code> concludes executing, effectively redirecting control flow in a way we desire!</p> <p>Of course, in order to actually do this, we will need to know where the code we want to run is located. This is where ASLR bypasses come in handy. By breaking the address randomization of a program, we can reveal where program instructions are located, and jump to them by overwriting return addresses (or any function pointers in a program). You can read <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Stack Smashing in the 21st Century</a> for more background on buffer overflows.</p> <h3 id="part-2a-ret2win-10"> <a href="#part-2a-ret2win-10" class="anchor-heading" aria-labelledby="part-2a-ret2win-10"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2A: <code class="language-plaintext highlighter-rouge">ret2win</code> (10%) </h3> <p>In this activity we will perform a <code class="language-plaintext highlighter-rouge">ret2win</code> attack. In a <code class="language-plaintext highlighter-rouge">ret2win</code> attack, the attacker replaces the return address with the address of a <code class="language-plaintext highlighter-rouge">win</code> method that, when called, does everything the attacker wants. The attacker does not need to control any arguments passed to <code class="language-plaintext highlighter-rouge">win</code>– we only care that <code class="language-plaintext highlighter-rouge">win</code> gets executed.</p> <p>The vulnerable method for this lab operates as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vulnerable</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">your_string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate 16 bytes on the stack</span>
    <span class="kt">char</span> <span class="n">stackbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="c1">// Copy the user input to the stack:</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">stackbuf</span><span class="p">,</span> <span class="n">your_string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Feel free to read the source code of <code class="language-plaintext highlighter-rouge">vulnerable</code> for a bit more info on how the stack works. For now, you can get the <code class="language-plaintext highlighter-rouge">win</code> address manually (without needing to use your ASLR bypass techniques developped in Part 1) as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cast win to a function pointer and then to a 64 bit int</span>
<span class="kt">uint64_t</span> <span class="n">win_address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">&amp;</span><span class="n">win</span><span class="p">;</span>
</code></pre></div></div> <p>After we run your code, we will print the resulting stack frame to the console so you can see how your attack worked. In this example, I’ve set <code class="language-plaintext highlighter-rouge">your_string</code> to 16 A’s (<code class="language-plaintext highlighter-rouge">'A' == 0x41</code>) followed by a new line (<code class="language-plaintext highlighter-rouge">'\n'</code>). So we see 16 <code class="language-plaintext highlighter-rouge">0x41</code>’s repeated on the stack. The newline does not appear as our version of <code class="language-plaintext highlighter-rouge">strcpy</code> doesn’t copy the ending new line byte.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is what the stack looks like now:
      +-----------------------------------------+
0x00: | 0x00007FFE055628B0 = 0x4141414141414141 | &lt;- stackbuf starts here
      +-----------------------------------------+
0x01: | 0x00007FFE055628B8 = 0x4141414141414141 |
      +-----------------------------------------+
0x02: | 0x00007FFE055628C0 = 0x00007FFE05562CE0 | &lt;- Saved RBP
      +-----------------------------------------+
0x03: | 0x00007FFE055628C8 = 0x000055FEF9B4E91A | &lt;- Return address!
      +-----------------------------------------+
</code></pre></div></div> <p>We provide you some sample code to fill in the string you pass to <code class="language-plaintext highlighter-rouge">vulnerable</code>. For your convenience, we treat your “string” as an array of 64-bit integers. This way you can directly write to a specific slot on the stack by indexing the provided array. For example, to set the saved RBP position (index 2), you can use <code class="language-plaintext highlighter-rouge">your_string[2] = 0x0123456789abcdef</code>.</p> <p><strong>Note on strcpy</strong>: To allow <code class="language-plaintext highlighter-rouge">NULL</code> characters into your buffer, we use a different definiton of <code class="language-plaintext highlighter-rouge">strcpy</code> than the libc one. Our <code class="language-plaintext highlighter-rouge">strcpy</code> allows <code class="language-plaintext highlighter-rouge">NULL</code> characters, but stops at newlines (<code class="language-plaintext highlighter-rouge">0x0A</code>, or <code class="language-plaintext highlighter-rouge">'\n'</code>). This is to mirror the behavior of <code class="language-plaintext highlighter-rouge">gets</code>, which is commonly used in CTF stack overflow problems.</p> <p><strong>Note on rbp</strong>: The base pointer rbp is reset upon entry to a C function (see line 2 of the <code class="language-plaintext highlighter-rouge">vulnerable</code> disassembly above). So you can set it to whatever you like during your overflow and it won’t make a difference (you will need to overwrite rbp to change the return address).</p> <blockquote class="exercise-title"> <p>Exercise 2-1</p> <p>Overwrite the return address in <code class="language-plaintext highlighter-rouge">vulnerable</code> with the address of <code class="language-plaintext highlighter-rouge">win</code>.</p> </blockquote> <blockquote class="warning-title"> <p>Note</p> <p>It’s ok if your code segfaults on occasion for Part 2A (it doesn’t have to work every time, so long as it works most of the time). This is because sometimes ASLR gives an address that has a new line in it, which means your overflow will stop early.</p> </blockquote> <h3 id="part-2b-return-oriented-programming-rop-20"> <a href="#part-2b-return-oriented-programming-rop-20" class="anchor-heading" aria-labelledby="part-2b-return-oriented-programming-rop-20"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2B: Return Oriented Programming (ROP) (20%) </h3> <p>In this part, we will perform a return oriented programming attack, or ROP. ROP is a technique devised to counteract Data Execution Prevention (DEP for short, otherwise known as W^X), which is a security feature introduced to protect against simply writing your own code into the stack and jumping to it. DEP and ASLR are the foundation of all modern exploit mitigations. Just like how ASLR can be sidestepped with an information leak, DEP can be defeated by ROP.</p> <p>The idea behind ROP is to construct a sequence of code by combining tiny “gadgets” together into a larger chain. ROP looks a lot like <code class="language-plaintext highlighter-rouge">ret2win</code>, except we add more things to the stack than just overwriting a single return address. Instead, we construct a chain of return addresses that are executed one after the other.</p> <p>Let’s take a look at two example ROP gadgets:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gadget_1:
    pop rdi
    ret

gadget_2:
    pop rsi
    ret
</code></pre></div></div> <p>The above sequences of code will pop the top value off the stack into <code class="language-plaintext highlighter-rouge">rdi</code> or <code class="language-plaintext highlighter-rouge">rsi</code>, and then return to the next address. We can combine them as follows to gain control of <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code> by writing the following to the stack:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+
|  OVERWRITTEN  | &lt;- Space for stackbuf
+---------------+
|  OVERWRITTEN  | &lt;- Saved RBP
+---------------+
|    gadget_1   | &lt;- Return address
+---------------+
| New rdi Value |
+---------------+
|    gadget_2   |
+---------------+
| New rsi Value |
+---------------+
| Next gadget...|
+---------------+
</code></pre></div></div> <p>We can encode desired values for <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">rsi</code> onto the stack alongside our return addresses. Then, by carefully controlling where code execution goes, we can make the gadgets perform arbitrary computation. In fact, it has been shown that <a href="https://github.com/pakt/ropc">ROP is Turing Complete</a> for sufficiently large programs.</p> <blockquote class="hint-title"> <p>Key Idea</p> <p>We can chain code sequences together by continuing to overflow the stack.</p> </blockquote> <p>For this problem, you will need to combine ROP gadgets to cause <code class="language-plaintext highlighter-rouge">call_me_maybe</code> to return the flag. You will use the same buffer overflow as we used in Part 2A, and you can get the address of a given gadget the same way we got the address of the <code class="language-plaintext highlighter-rouge">win</code> function.</p> <p>The gadgets are defined in <code class="language-plaintext highlighter-rouge">gadgets.s</code>. <code class="language-plaintext highlighter-rouge">call_me_maybe</code> is defined below:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">call_me_maybe</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">rdi</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">rsi</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">rdx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">rdi</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rsi</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rdi</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rdx</span> <span class="o">==</span> <span class="mi">1337</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"MIT{flag_goes_here}</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Incorrect arguments!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"You did call_me_maybe(0x%lX, 0x%lX, 0x%lX);</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rdi</span><span class="p">,</span> <span class="n">rsi</span><span class="p">,</span> <span class="n">rdx</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote class="exercise-title"> <p>Exercise 2-2</p> <p>Construct a ROP chain to call <code class="language-plaintext highlighter-rouge">call_me_maybe</code> with satisfactory arguments.</p> </blockquote> <blockquote class="warning-title"> <p>Note</p> <p>It’s ok if your code segfaults on occasion for Part 2B (it doesn’t have to work every time, so long as it works most of the time). This is because sometimes ASLR gives an address that has a new line in it, which means your overflow will stop early.</p> </blockquote> <blockquote class="hint"> <p>If you are experiencing crashes and don’t know why, you can use <a href="https://www.sourceware.org/gdb/documentation/">GDB</a> to help figure out where your exploit is going wrong.</p> </blockquote> <blockquote class="hint-title"> <p>Stack Alignment</p> <p>If your code seems like it should work (the correct arguments are passed to <code class="language-plaintext highlighter-rouge">call_me_maybe</code>, yet your program keeps crashing), it is likely due to a problem called stack alignment. The System V C ABI requires that the stack is 16 byte aligned when entering a function. When we mess about with the stack in a buffer overflow attack, we can sometimes change that alignment. There is a simple solution here- use a single <code class="language-plaintext highlighter-rouge">ret</code> gadget to realign the stack to 16 bytes. You can get the address of a <code class="language-plaintext highlighter-rouge">ret</code> instruction from <code class="language-plaintext highlighter-rouge">objdump</code> (use the <code class="language-plaintext highlighter-rouge">ret</code> instruction from any of the 6 provided gadgets).</p> </blockquote> <h2 id="part-3-putting-it-all-together-10"> <a href="#part-3-putting-it-all-together-10" class="anchor-heading" aria-labelledby="part-3-putting-it-all-together-10"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 3: Putting it All Together (10%) </h2> <p>We are now going to combine the ASLR bypasses in Part 1 with the ROP chain you wrote in Part 2. The random page from Part 1 will contain the same sequence of ROP gadgets that you had access to in Part 2B. Additionally, it will be marked executable so that it can be executed if you jump to it.</p> <h3 class="no_toc" id="dumping-the-gadgets"> <a href="#dumping-the-gadgets" class="anchor-heading" aria-labelledby="dumping-the-gadgets"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dumping the gadgets </h3> <p>The hidden page from Part 1 will be filled with the code from the <code class="language-plaintext highlighter-rouge">gadgets.o</code> file, which can be generated by running <code class="language-plaintext highlighter-rouge">./check.py 3</code>. Dump the contents of <code class="language-plaintext highlighter-rouge">gadgets.o</code> with the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objdump <span class="nt">-d</span> gadgets.o <span class="nt">-M</span> intel
</code></pre></div></div> <p>Objdump will report something like the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Disassembly of section .text:

0000000000000000 &lt;gadget1&gt;:
   0:   5f                      pop    rdi
   1:   c3                      ret
        ...

0000000000000010 &lt;gadget2&gt;:
  10:   5e                      pop    rsi
  11:   c3                      ret
</code></pre></div></div> <p>The line <code class="language-plaintext highlighter-rouge">0000000000000000 &lt;gadget1&gt;:</code> tells you the relative distance of <code class="language-plaintext highlighter-rouge">gadget1</code> from the randomized base address. In this case, <code class="language-plaintext highlighter-rouge">gadget1</code> will be located at <code class="language-plaintext highlighter-rouge">hidden_page[0x0000]</code> and <code class="language-plaintext highlighter-rouge">gadget2</code> will be at <code class="language-plaintext highlighter-rouge">hidden_page[0x0010]</code> (where <code class="language-plaintext highlighter-rouge">hidden_page</code> is a <code class="language-plaintext highlighter-rouge">uint8_t *</code> that points to the page your Part 1 code found). As ASLR slides everything together by applying a constant offset, <code class="language-plaintext highlighter-rouge">gadget2</code> will always be <code class="language-plaintext highlighter-rouge">0x10</code> bytes after <code class="language-plaintext highlighter-rouge">gadget1</code>, no matter where ASLR places them.</p> <blockquote class="hint-title"> <p>Key Idea</p> <p>Relative distances between instructions are preserved under ASLR.</p> </blockquote> <h3 class="no_toc" id="performing-the-attack"> <a href="#performing-the-attack" class="anchor-heading" aria-labelledby="performing-the-attack"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Performing the Attack </h3> <p>For Part 3, you will need to reconstruct your ROP chain using the gadgets dumped from <code class="language-plaintext highlighter-rouge">objdump</code>. Then, you will combine your code from Part 1 with the reconstructed Part 2 chain to complete a full ROP attack in the hidden page.</p> <p>Your attack will do the following:</p> <ol> <li>Locate the hidden <code class="language-plaintext highlighter-rouge">mmap</code> page with your choice of technique from Part 1.</li> <li>Construct a ROP chain using the gadgets in the hidden page (with offsets calculated from <code class="language-plaintext highlighter-rouge">objdump</code>).</li> <li>Call <code class="language-plaintext highlighter-rouge">vulnerable</code> with your payload configured.</li> </ol> <blockquote class="exercise-title"> <p>Exercise 3-1</p> <p>Combine your Part 1 and Part 2 attacks to defeat Part 3. On success, you should see the success flag printed to the console.</p> </blockquote> <blockquote class="hint-title"> <p>A note on realism</p> <p>You may be wondering why we bother with jumping to a sequence of ROP gadgets if we already have control of C code. This is to simulate attacking a real program without the ability to run code within the victim context (for example, attacking the kernel from userspace, or attacking a remote server over a <code class="language-plaintext highlighter-rouge">netcat</code> connection).</p> </blockquote> <h3 class="no_toc" id="grading-3"> <a href="#grading-3" class="anchor-heading" aria-labelledby="grading-3"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Grading </h3> <p>Commit all the required C file to Github. Check your code from all the parts with the check script and make sure it passes. As always, submit your discussion questions as a PDF to <a href="https://www.gradescope.com/courses/965204">Gradescope</a>.</p> <h2 class="no_toc" id="contributors"> <a href="#contributors" class="anchor-heading" aria-labelledby="contributors"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Contributors </h2> <p>Made by Joseph Ravichandran and Mengjia Yan.</p> <h2 id="references"> <a href="#references" class="anchor-heading" aria-labelledby="references"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> References </h2> <p>[1] Daniel Gruss et al. <em>Prefetch Side-Channel Attacks: Bypassing SMAP and Kernel ASLR.</em> 2016. DOI:<a href="https://doi.org/10.1145/2976749.2978356">https://doi.org/10.1145/2976749.2978356</a></p> <p>[2] Enes Göktas et al. <em>Speculative Probing: Hacking Blind in the Spectre Era.</em> 2020. DOI:<a href="https://doi.org/10.1145/3372297.3417289">https://doi.org/10.1145/3372297.3417289</a></p> <p>[3] <a href="https://github.com/IAIK/prefetch/blob/master/addrspace/addrspace.c">IAIK Prefetch Paper Code</a></p> <p>[4] <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel Software Developer’s Manual</a></p> <p>[5] <a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Stack Smashing in the 21st Century</a></p> <p>[6] Daniel Gruss et al. <em>KASLR is Dead: Long Live KASLR.</em> 2017.</p> <p>[7] Ben Gras et al. <em>ASLR on the Line: Practical Cache Attacks on the MMU.</em> NDSS (2017).</p> <p>[8] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazières and D. Boneh, <em>“Hacking Blind,”</em> 2014 IEEE Symposium on Security and Privacy, 2014, pp. 227-242, doi: 10.1109/SP.2014.22.</p> <p>[9] <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GNU Extended Inline Assembly Manual</a></p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
