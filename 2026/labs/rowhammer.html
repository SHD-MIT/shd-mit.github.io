<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2026/assets/css/just-the-docs-default.css"> <script src="/2026/assets/js/vendor/lunr.min.js"></script> <script src="/2026/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Rowhammer | 6.5950/6.5951</title> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="Rowhammer" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Secure Hardware Design" /> <meta property="og:description" content="Secure Hardware Design" /> <meta property="og:site_name" content="6.5950/6.5951" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Rowhammer" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Secure Hardware Design","headline":"Rowhammer","url":"/2026/labs/rowhammer.html"}</script> <!-- End Jekyll SEO tag --> <div id="preload-cover"></div> <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" /> <style> #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#fff; z-index:9999; } @media (prefers-color-scheme: dark) { #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#222326; z-index:9999; } } </style> <script> window.addEventListener('load', function() { var cover = document.getElementById('preload-cover'); cover.style.display = 'none'; }); </script> <script type="text/javascript" src="/2026/assets/js/theme-switch.js" defer></script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous"> <!-- The loading of KaTeX is deferred to speed up page rendering --> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script> <!-- To automatically render math in text elements, include the auto-render extension: --> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Feather. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/2026/" class="site-title lh-tight"> 6.5950/6.5951 </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/2026/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2026/calendar.html" class="nav-list-link">Calendar</a></li><li class="nav-list-item"><a href="/2026/lectureReadings.html" class="nav-list-link">Lecture Readings</a></li><li class="nav-list-item"><a href="/2026/paperDiscussion.html" class="nav-list-link">Paper Discussion</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Recitations category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2026/recitations.html" class="nav-list-link">Recitations</a><ul class="nav-list "><li class="nav-list-item "><a href="/2026/recitations/cpp.html" class="nav-list-link">CTF of C Programming</a></li><li class="nav-list-item "><a href="/2026/recitations/cache.html" class="nav-list-link">Cache Recitation</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2026/labs.html" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item "><a href="/2026/infrastructure.html" class="nav-list-link">Infrastructure</a></li><li class="nav-list-item "><a href="/2026/labs/ccc.html" class="nav-list-link">C Crash Course</a></li><li class="nav-list-item "><a href="/2026/labs/fingerprinting.html" class="nav-list-link">Website Fingerprinting</a></li><li class="nav-list-item "><a href="/2026/labs/cache.html" class="nav-list-link">Cache Attacks</a></li><li class="nav-list-item "><a href="/2026/labs/spectre.html" class="nav-list-link">Spectre Attacks</a></li><li class="nav-list-item active"><a href="/2026/labs/rowhammer.html" class="nav-list-link active">Rowhammer</a></li></ul></li><li class="nav-list-item"><a href="/2026/paperReadingGuidance.html" class="nav-list-link">Paper Readings Guidance</a></li><li class="nav-list-item"><a href="/2026/forInstructors.html" class="nav-list-link">For Instructors</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search 6.5950/6.5951" aria-label="Search 6.5950/6.5951" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> <!-- Solution based on https://github.com/just-the-docs/just-the-docs/issues/1223 Concrete implementation copied from https://github.com/mmcesim/mmcesim.org --> <nav aria-label="Auxiliary" class="aux-nav"> <!-- Set up the icons --> <svg id="toggle-theme-icon" xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-sun" viewBox="0 0 24 24"> <title>Light mode</title> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </symbol> <symbol id="svg-moon" viewBox="0 0 24 24"> <title>Dark mode</title> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon"> <path stroke="none" d="M0 0h24v24H0z" fill="none" /> <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" /> </svg> </symbol> </svg> <!-- Nav list --> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/6595-sp26/" class="site-button" > GitHub </a> </li> <li class="aux-nav-list-item"> <a href="https://piazza.com/mit/spring2026/6595065951" class="site-button" > Piazza </a> </li> <li class="aux-nav-list-item"> <a href="https://www.gradescope.com/courses/1232671" class="site-button" > Gradescope </a> </li> <li class="aux-nav-list-item"> <a href="https://mit.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx?folderID=e2945168-bc1e-4b46-8077-b3d200fe19d5" class="site-button" > Panopto </a> </li> <!-- With added icon --> <li class="aux-nav-list-item"> <a id="theme-toggle" class="site-button"><svg width='18px' height='18px'> <use href="#svg-sun"></use> </svg></a> </li> </ul> </nav> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/2026/labs.html">Labs</a></li> <li class="breadcrumb-nav-list-item"><span>Rowhammer</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="rowhammer-lab"> <a href="#rowhammer-lab" class="anchor-heading" aria-labelledby="rowhammer-lab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Rowhammer Lab </h1> <p><strong>Due Date: Apr 2</strong>; Last Updated Date: Feb 18</p> <h2 class="no_toc" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h2> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#part-0-lab-infrastructure" id="markdown-toc-part-0-lab-infrastructure">Part 0: Lab Infrastructure</a> <ul> <li><a href="#debug-htcondor" id="markdown-toc-debug-htcondor">Debug HTCondor</a></li> </ul> </li> <li><a href="#part-1-bridging-the-virtual-and-physical-address-spaces-10" id="markdown-toc-part-1-bridging-the-virtual-and-physical-address-spaces-10">Part 1: Bridging the Virtual and Physical Address Spaces (10%)</a> <ul> <li><a href="#translating-virtual-to-physical-addresses" id="markdown-toc-translating-virtual-to-physical-addresses">Translating Virtual to Physical Addresses</a></li> <li><a href="#translating-in-the-other-direction" id="markdown-toc-translating-in-the-other-direction">Translating in the Other Direction</a></li> </ul> </li> <li><a href="#part-2-dram-geometry---finding-bank-conflicts-20" id="markdown-toc-part-2-dram-geometry---finding-bank-conflicts-20">Part 2: DRAM Geometry - Finding Bank Conflicts (20%)</a></li> <li><a href="#part-3-dram-geometry---bank-xor-function-20" id="markdown-toc-part-3-dram-geometry---bank-xor-function-20">Part 3: DRAM Geometry - Bank XOR-Function (20%)</a> <ul> <li><a href="#the-xor-bank-mapping-function" id="markdown-toc-the-xor-bank-mapping-function">The XOR Bank Mapping Function</a></li> </ul> </li> <li><a href="#part-4-its-rowhammer-time-20" id="markdown-toc-part-4-its-rowhammer-time-20">Part 4: It’s Rowhammer Time! (20%)</a></li> <li><a href="#part-5-mitigation-using-error-correcting-codes-30" id="markdown-toc-part-5-mitigation-using-error-correcting-codes-30">Part 5: Mitigation using Error Correcting Codes (30%)</a> <ul> <li><a href="#understanding-ecc-types-and-design-choices" id="markdown-toc-understanding-ecc-types-and-design-choices">Understanding ECC: Types and Design Choices</a></li> <li><a href="#implementing-ecc-hamming2216" id="markdown-toc-implementing-ecc-hamming2216">Implementing ECC: Hamming(22,16)</a></li> </ul> </li> <li><a href="#behind-the-scene-how-this-lab-infrastructure-was-developed" id="markdown-toc-behind-the-scene-how-this-lab-infrastructure-was-developed">Behind the Scene: How this lab infrastructure was developed?</a></li> </ul> <h3 class="no_toc" id="collaboration-policy"> <a href="#collaboration-policy" class="anchor-heading" aria-labelledby="collaboration-policy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Collaboration Policy </h3> <p>Our full Academic Honesty policy can be found on the <a href="../index.html#collaboration-policy">Course Information page</a> of our website. As a reminder, all 6.5950/6.5951 labs should be completed individually. You may discuss the lab at a high level with a classmate, but you may not work on code together or share any of your code.</p> <h3 class="no_toc" id="getting-started"> <a href="#getting-started" class="anchor-heading" aria-labelledby="getting-started"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h3> <p>You will complete this lab primarily in C and C++. Refer to the <a href="../recitations/cpp.html">recitation materials</a> if needed.</p> <p>We are using <code class="language-plaintext highlighter-rouge">git</code> for all the labs – instructions for setting up the git repository can be found on the <a href="../labs.html#github">labs page</a>.</p> <p>In addition to submitting code, you are required to submit a PDF lab report containing your answers to Discussion Questions to <a href="https://www.gradescope.com/courses/1232671">Gradescope</a>. We provide a markdown template in the starter code (<code class="language-plaintext highlighter-rouge">report.md</code>).</p> <h2 id="introduction"> <a href="#introduction" class="anchor-heading" aria-labelledby="introduction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introduction </h2> <p>In this lab, you will complete two tasks:</p> <ol> <li>Mount a Rowhammer attack on a real machine, taking the theory we learned in class to practice.</li> <li>Study what we can do to protect against Rowhammer.</li> </ol> <p>To begin, imagine DRAM as a matrix of cells. The core of Rowhammer is to access the cells that are adjacent to each other in a specific pattern. In lecture, we studied how to design a reasonable access pattern to perform double-sided Rowhammer, and you may think the attack sounds easy to pull off. Unfortunately, it is not. The most tricky part of the attack is dealing with address translations, and figuring out how exactly we can access the bit cells needed. Note that all the addresses that a programmer (e.g., you) can manipulate are <em>virtual addresses</em>, which need to be translated to <em>physical addresses</em>, and then to <em>DRAM cell coordinates</em>.</p> <p style="text-align: center;"><strong>Virtual Address → Physical Address → DRAM Cell Coordinate</strong></p> <p>Since each step isn’t trivial, we’ve designed the lab to guide you to build your attack step by step, handling one of the translations at a time. At the end of this lab, you will not only have a working Rowhammer attack, but also gain a deeper understanding of the complex addressing mechanism that is widely used in modern systems.</p> <h2 id="part-0-lab-infrastructure"> <a href="#part-0-lab-infrastructure" class="anchor-heading" aria-labelledby="part-0-lab-infrastructure"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 0: Lab Infrastructure </h2> <p>Due to the intrinsic physical requirements of the Rowhammer vulnerability, your experiments will be run on our special lab machines. These machines have been verified to reliably be vulnerable to Rowhammer, and your lab answers will be specific to these machines’ configuration.</p> <p>The experiments also require to exclusively use the whole DRAM. To achieve this, we will use <a href="https://htcondor.org/htcondor/overview/"><strong>HTCondor</strong></a> to time-shared the lab machines, running one experiment at a time. You will <code class="language-plaintext highlighter-rouge">ssh</code> to <code class="language-plaintext highlighter-rouge">unicorn.csail.mit.edu</code>, develop and build your code on it, and use HTCondor on it to remotely launch your code on one of the vulnerable machines (<code class="language-plaintext highlighter-rouge">csg-exp{6,7,9}</code> and <code class="language-plaintext highlighter-rouge">arch-sec-{5-8}</code>). Note that you will not be directly accessing these vulnerable machines, since this may interfere with another student’s experiments.</p> <blockquote class="exercise-title"> <p>Configuration</p> <p>Your assigned machine information has been emailed to you. Before moving past this point, edit <code class="language-plaintext highlighter-rouge">launch.condor</code> and update the <code class="language-plaintext highlighter-rouge">Requirements</code> line to match the specific machine assigned to you. Make sure you exclude the <code class="language-plaintext highlighter-rouge">.csail.mit.edu</code> suffix when filling it.</p> </blockquote> <h3 class="no_toc" id="use-htcondor"> <a href="#use-htcondor" class="anchor-heading" aria-labelledby="use-htcondor"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Use HTCondor </h3> <p>You will use HTCondor to launch your attack code, using the following commands to interact with HTCondor:</p> <ul> <li><code class="language-plaintext highlighter-rouge">./launch.sh [BINARY FILE]</code>: run the specified binary file <code class="language-plaintext highlighter-rouge">bin/[BINARY FILE]</code> on your assigned remote machine. The output will be placed in <code class="language-plaintext highlighter-rouge">log/[BINARY FILE].out</code>, and any errors generated by your code will be placed in <code class="language-plaintext highlighter-rouge">log/[BINARY FILE].error</code>.</li> <li><code class="language-plaintext highlighter-rouge">cat log/[BINARY FILE].out</code>: Check the output of your job by opening the corresponding output file.</li> <li><code class="language-plaintext highlighter-rouge">cat log/[BINARY FILE].error</code>: Print all the errors experienced by your job by opening the corresponding error file.</li> </ul> <p>Here is an example of using HTCondor to run a program that prints Hello World.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make

<span class="nv">$ </span>./launch.sh part0
  Submitting job<span class="o">(</span>s<span class="o">)</span><span class="nb">.</span>
  1 job<span class="o">(</span>s<span class="o">)</span> submitted to cluster XX.
  All <span class="nb">jobs </span><span class="k">done</span><span class="nb">.</span>

<span class="nv">$ </span><span class="nb">cat </span>log/part0.out
  Hello World!
</code></pre></div></div> <blockquote class="warning"> <p>Before continuing, run the Condor commands as above, and ensure that you can interact with your assigned machine correctly. If things do not work as expected, read the next subsection for debugging tips or reach out to TAs.</p> </blockquote> <h3 id="debug-htcondor"> <a href="#debug-htcondor" class="anchor-heading" aria-labelledby="debug-htcondor"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Debug HTCondor </h3> <p>By default, <code class="language-plaintext highlighter-rouge">./launch.sh</code> will wait for the binary finishing the execution. However, it might hang forever either because the binary itself hangs forever or becuase condor fails to schedule the binary to remote machines. In either case, you can type <code class="language-plaintext highlighter-rouge">Ctrl+c</code> to exit from <code class="language-plaintext highlighter-rouge">./launch.sh</code> and using following commands to figure out what’s going wrong:</p> <ul> <li><code class="language-plaintext highlighter-rouge">condor_q</code>: Check the status of your job, including its ID and its Status. You can see more debugging information with the <code class="language-plaintext highlighter-rouge">condor_q -better-analyze [ID]</code> or <code class="language-plaintext highlighter-rouge">cat log/[BINARY FILE].log</code>.</li> <li><code class="language-plaintext highlighter-rouge">condor_rm [ID]</code>: Kill your job specified by the ID. Make sure you killed (or finished) all your jobs before launching new ones. Note that we config Condor to kill your jobs automatically after they have executed for 10 minutes, to allow other students to use the machine.</li> </ul> <p>Here is an example that Condor cannot schedule a job becuase you forget to fill your machine name into <code class="language-plaintext highlighter-rouge">launch.sh</code>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make

<span class="nv">$ </span>./launch.sh part0
  Submitting job<span class="o">(</span>s<span class="o">)</span><span class="nb">.</span>
  1 job<span class="o">(</span>s<span class="o">)</span> submitted to cluster 6522.
  ^C

<span class="nv">$ </span>condor_q
  <span class="nt">--</span> Schedd: arch-sec-1.csail.mit.edu : &lt;128.30.65.18:9618?... @ 02/19/24 18:42:02
  OWNER     BATCH_NAME    SUBMITTED   DONE   RUN    IDLE  TOTAL JOB_IDS
  shd24-xxx ID: 6522     2/19 18:41      _      _      1      1 6522.0

<span class="nv">$ </span>condor_q <span class="nt">-better-analyze</span> 6522
  ...
  No successful match recorded.
  ...

<span class="nv">$ </span>condor_rm 6522
</code></pre></div></div> <h2 id="part-1-bridging-the-virtual-and-physical-address-spaces-10"> <a href="#part-1-bridging-the-virtual-and-physical-address-spaces-10" class="anchor-heading" aria-labelledby="part-1-bridging-the-virtual-and-physical-address-spaces-10"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1: Bridging the Virtual and Physical Address Spaces (10%) </h2> <p>We start with bridging the gap between the virtual and physical address spaces. Specifically, you will implement two functions: Firstly, a function that translates a virtual address to its corresponding physical address. Secondly, a function translating in the opposite direction, i.e., given a physical address, determining its corresponding virtual address.</p> <h3 class="no_toc" id="code-skeleton"> <a href="#code-skeleton" class="anchor-heading" aria-labelledby="code-skeleton"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Code Skeleton </h3> <p>The source code for this lab can be found in <code class="language-plaintext highlighter-rouge">src/</code>, and is separated into folders corresponding to different parts of the lab.</p> <ul> <li><code class="language-plaintext highlighter-rouge">src/params.hh</code>: Defines several key parameters, including the size of a hugepage (e.g. 2MB), the size of a DRAM row, etc.</li> <li><code class="language-plaintext highlighter-rouge">src/verif.hh</code>: Contains declarations for functions which will help you check your solutions, and will be used for grading. The implementation of these functions are in <code class="language-plaintext highlighter-rouge">bin/libverif.so</code>. Don’t bother decompiling - the library has been obfuscated so that it will take more effort to reverse engineer than solving as intended!</li> <li><code class="language-plaintext highlighter-rouge">src/shared.hh</code> and <code class="language-plaintext highlighter-rouge">src/shared.cc</code>: Contain functions which are shared across different parts of the lab. You will complete these functions in Part 1.</li> </ul> <p>You can compile the code by running the command <code class="language-plaintext highlighter-rouge">make</code> at the root of the repository, which will create five executable files (<code class="language-plaintext highlighter-rouge">part[0-5]</code>) in the <code class="language-plaintext highlighter-rouge">bin/</code> folder. Note that you will need to re-run <code class="language-plaintext highlighter-rouge">make</code> <strong>each time</strong> you change your code to re-compile it. For example, observe the initial behavior of the initial codebase:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make

<span class="nv">$ </span>./launch.sh part1
  Submitting job<span class="o">(</span>s<span class="o">)</span><span class="nb">.</span>
  1 job<span class="o">(</span>s<span class="o">)</span> submitted to cluster XX.
  All <span class="nb">jobs </span><span class="k">done</span><span class="nb">.</span>

<span class="nv">$ </span><span class="nb">cat </span>log/part1.out
  virt_to_phys <span class="nb">test </span>failed!
</code></pre></div></div> <blockquote class="warning"> <p>Before continuing, run <code class="language-plaintext highlighter-rouge">make</code> and make sure your codebase compiles successfully and returns the same output as above.</p> </blockquote> <h3 class="no_toc" id="linuxs-pagemap-interface"> <a href="#linuxs-pagemap-interface" class="anchor-heading" aria-labelledby="linuxs-pagemap-interface"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Linux’s <code class="language-plaintext highlighter-rouge">pagemap</code> interface </h3> <p>The machines in this lab used <em>paged virtual memory</em> (if you need a refresher on this topic, check out 6.191’s (6.004’s) lectures on <a href="../lectures/readings/6191-fall2023/L17.pdf">Virtual Memory 1</a> and <a href="../lectures/readings/6191-fall2023/L18.pdf">Virtual Memory 2</a>).</p> <p>Linux provides the <code class="language-plaintext highlighter-rouge">pagemap</code> interface that allows userspace programs to examine page tables and related information. For a running process, its <code class="language-plaintext highlighter-rouge">pagemap</code> can be accessed by reading the file <code class="language-plaintext highlighter-rouge">/proc/self/pagemap</code>. This pagemap file is binary-encoded, containing a sequence of 64-bit values. Each 64-bit value corresponds to a virtual page (<em>assuming a page size of 4KB</em>), where the N-th 64-bit value corresponds to the N-th virtual page. The figure below indicates the semantics for each page entry.</p> <div style="text-align:center"><img src="figures/rowhammer_pagemap.png" width="65%" /></div> <p style="color:gray; font-size: 90%; text-align: center;"><em>Example Page Map Entry</em></p> <p>Bit 63 indicates whether the page presents in memory or not. If the page is present in memory, Bits 0-54 of the entry is the physical page number (PPN). The remaining (metadata) bits have their own meaning, which are not relevant for this lab. If you’re curious, more information can be found in the corresponding <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt">Linux kernel documentation page</a>.</p> <blockquote class="warning-title"> <p>Note</p> <p>As a countermeasure of Rowhammer, <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt"><code class="language-plaintext highlighter-rouge">/proc/self/pagemap</code> is not allowed to be accessed by non-sudo user since Linux 4.0</a> (released in 2015). However, we definitely do not want to give you sudo permission on our lab machine! Thankfully (for us), our TA, William Liu, developed a workaround through a kernel module, detailed in <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed">the section at the end of this handout</a>.</p> </blockquote> <h3 id="translating-virtual-to-physical-addresses"> <a href="#translating-virtual-to-physical-addresses" class="anchor-heading" aria-labelledby="translating-virtual-to-physical-addresses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Translating Virtual to Physical Addresses </h3> <p>We can leverage the <code class="language-plaintext highlighter-rouge">pagemap</code> interface to perform the virtual address to physical address translation. In the <code class="language-plaintext highlighter-rouge">virt_to_phys</code> function in <code class="language-plaintext highlighter-rouge">shared.cc</code>, you will translate a given virtual address to its corresponding physical address. You will implement this function assuming the page size is 4KB. At a high-level, your <code class="language-plaintext highlighter-rouge">virt_to_phys</code> function will do the following:</p> <ol> <li>Given a virtual address, derive the address’ virtual page number (VPN).</li> <li><em>(provided)</em> Read <code class="language-plaintext highlighter-rouge">pagemap</code> to find the corresponding page table entry.</li> <li><em>(provided)</em> Extract the physical page number (PPN) from the page table entry.</li> <li>Compute the physical address from the physical page number (PPN).</li> </ol> <blockquote class="exercise-title"> <p>1-1 Exercise</p> <p>Complete the <code class="language-plaintext highlighter-rouge">virt_to_phys</code> function in <code class="language-plaintext highlighter-rouge">src/shared.cc</code> assuming 4KB page size. Test your code by running <code class="language-plaintext highlighter-rouge">./launch.sh part1</code>. You should see <code class="language-plaintext highlighter-rouge">virt_to_phys test passed!</code></p> </blockquote> <blockquote class="hint"> <p>When you bit-shift the 55-bit PPN, you may notice that the upper bits cannot fit in a 64-bit address. You can ignore this effect, since the upper three bits of the PPN field are unused on our system.</p> </blockquote> <blockquote class="hint"> <p><strong>Tips for Programming in C/C++</strong></p> <ul> <li>Be cautious when you try to set every bit in a row to 1. You need to pay extra attention to the size of the variable. For example, <code class="language-plaintext highlighter-rouge">uint8_t x = 1</code> means <code class="language-plaintext highlighter-rouge">x=8'b00000001</code>, consisting of seven 0s and only one 1s.</li> <li>When you are writing your code, you may need to convert between integers (<code class="language-plaintext highlighter-rouge">uint64_t</code>) and pointers (<code class="language-plaintext highlighter-rouge">uint8_t *</code>) and vice-versa. You may find C++’s <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> useful in performing these conversions: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">uint64_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span> <span class="c1">// A 64bit integer</span>

  <span class="c1">// Cast the 64bit integer to a pointer</span>
  <span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">addr_ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">volatile</span> <span class="kt">uint8_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

  <span class="kt">uint8_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">addr_ptr</span><span class="p">;</span> <span class="c1">// Read using the casted pointer</span>
</code></pre></div> </div> </li> <li>Throughout your code, we suggest always using <code class="language-plaintext highlighter-rouge">uint64_t</code> rather than <code class="language-plaintext highlighter-rouge">int</code>, since <code class="language-plaintext highlighter-rouge">int</code>s can result in silent overflows when shifted by large values.</li> <li>Be mindful that the <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">order of operations</a> in C++ may not be what you expect. For instance, <code class="language-plaintext highlighter-rouge">a &lt;&lt; 12 - 1</code> is different from <code class="language-plaintext highlighter-rouge">(a &lt;&lt; 12) - 1</code>. If in doubt, use parenthesis.</li> </ul> </blockquote> <h3 id="translating-in-the-other-direction"> <a href="#translating-in-the-other-direction" class="anchor-heading" aria-labelledby="translating-in-the-other-direction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Translating in the Other Direction </h3> <p>You will find it handy if you can perform address translation in the opposite direction, from physical to virtual addresses. The idea is to construct a <em>reverse</em> page table, i.e., a map that records the mapping relationship from physical page numbers (PPN) to virtual page numbers (VPN). In <code class="language-plaintext highlighter-rouge">shared.cc</code>, <code class="language-plaintext highlighter-rouge">PPN_VPN_map</code> serves as the reverse page table. It is a dictionary implemented using C++’s <code class="language-plaintext highlighter-rouge">std::map</code> syntax, with physical page numbers as keys and virtual page numbers as values. For more information related to C++ and examples of how to use the <code class="language-plaintext highlighter-rouge">std::map</code> object, refer to the <a href="../recitations/cpp.html#c-maps-stdmap">recitation materials</a>.</p> <p>Your task is to complete the function <code class="language-plaintext highlighter-rouge">setup_PPN_VPN_map</code> (in <code class="language-plaintext highlighter-rouge">shared.cc</code>) to populate the <code class="language-plaintext highlighter-rouge">PPN_VPN_map</code> data structure. You can assume the page size is <strong>2MB</strong> as opposed to 4KB. The populated reverse page table should cover a 2GB region following the pointer <code class="language-plaintext highlighter-rouge">mem_map</code>.</p> <blockquote class="discussion-title"> <p>1-2 Discussion Question</p> <p>In a 64-bit system using 4KB pages, which bits are used to represent the page offset, and which are used to represent the page number?</p> <p>How about for a 64-bit system using 2MB pages? Which bits are used for page number and which are for page offset?</p> <p>In a 2GB buffer, how many 2MB hugepages are there?</p> </blockquote> <blockquote class="hint"> <p><strong>Demystifying 2MB vs. 4KB Page Sizes</strong></p> <p>You are asked to use 4KB page to probe the <code class="language-plaintext highlighter-rouge">pagemap</code> interface, but 2MB page to build the reverse page table. You may wonder – why do we use inconsistent page sizes and will it not introduce bugs?</p> <p>In our setup, we ask the OS to give us the 2GB region using hugepages (2MB page size) inside the <code class="language-plaintext highlighter-rouge">allocate_pages</code> function. We use hugepages to simplify the address translation step (using 2MB pages allows us to more easily determine the DRAM bank of an address later on in this lab). The <code class="language-plaintext highlighter-rouge">pagemap</code> interface is designed, however, to assume 4KB pages, with each 64-bit entry corresponding to one 4KB page.</p> <p>As we know that for address translation, we take the VPN and translate it to PPN, but keep the page offset unchanged. So a virtual address and its corresponding physical address always have <em>the same page offset</em>. When considering 2MB and 4KB pages, we can consider a 2MB page to consist of 512 4KB pages. For these 4KB pages, the lower 9 bits of their VPNs are counted as page offset for a 2MB page. Therefore, when being translated between virtual and physical address, these 9 bits do not need to be changed.</p> </blockquote> <blockquote class="warning"> <p>One quirk with C++ maps is that C++ will return 0 (i.e., <code class="language-plaintext highlighter-rouge">NULL</code>) instead of throwing an error if you try to retrieve a value which isn’t in the map. You can force an exception with <code class="language-plaintext highlighter-rouge">.at</code>. You will only encounter addresses with non-zero virtual page numbers in this lab, so you may want to check for lookups which return zero!</p> </blockquote> <blockquote class="exercise-title"> <p>1-3 Exercise</p> <p>Complete the <code class="language-plaintext highlighter-rouge">setup_PPN_VPN_map</code> function in <code class="language-plaintext highlighter-rouge">src/shared.cc</code> to populate the reverse page table. Test your code by running <code class="language-plaintext highlighter-rouge">./launch.sh part1</code>. You should see <code class="language-plaintext highlighter-rouge">PPN_VPN test passed!</code></p> </blockquote> <blockquote class="exercise-title"> <p>1-4 Exercise</p> <p>Complete the <code class="language-plaintext highlighter-rouge">phys_to_virt</code> function in <code class="language-plaintext highlighter-rouge">src/shared.cc</code>: given a physical address, determine its corresponding virtual address. You will need to use the reverse page table <code class="language-plaintext highlighter-rouge">PPN_VPN_map</code> that you have constructed. Test your code by running <code class="language-plaintext highlighter-rouge">./launch.sh part1</code>. You should see <code class="language-plaintext highlighter-rouge">phys_to_virt test passed!</code></p> </blockquote> <h3 class="no_toc" id="submission-and-grading"> <a href="#submission-and-grading" class="anchor-heading" aria-labelledby="submission-and-grading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Relevant files to submit to GitHub: <code class="language-plaintext highlighter-rouge">src/shared.cc</code></p> <h2 id="part-2-dram-geometry---finding-bank-conflicts-20"> <a href="#part-2-dram-geometry---finding-bank-conflicts-20" class="anchor-heading" aria-labelledby="part-2-dram-geometry---finding-bank-conflicts-20"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2: DRAM Geometry - Finding Bank Conflicts (20%) </h2> <blockquote class="warning-title"> <p>Part 2-3 and Part 4 of this lab have no dependencies between each other. If you want to build up to the setup behind a Rowhammer attack, proceed in the lab order. If you want to flip bits, proceed to Part 4.</p> </blockquote> <p>To perform Rowhammer in real life on a specific victim row, you would have to locate attack rows by reverse engineering the physical address to DRAM coordinate mapping. Note that adjacent rows of memory <strong>might not be</strong> a constant stride apart in the physical memory space. Why is this the case?</p> <p>This added complexity is introduced due to the geometry of the DRAM. Consider a DRAM coordinate of a bit cell is a tuple of &lt;DIMM id, Channel id, Rank id, Bank id, Row id, Column id&gt; (see details in the lecture slides). Recall that for two rows to be physically adjacent to one another in a DRAM chip, they must have the same &lt;DIMM id, Channel id, Rank id, Bank id&gt;, and their &lt;Row id&gt; should differ by 1. In most DRAMs, each of the &lt;DIMM id, Channel id, Rank id, Bank id&gt; is derived by XORing a selection of bits from the physical address. These XOR functions, i.e., which bits are used to perform the XOR operation, are proprietary information and are not typically provided by CPU vendors.</p> <p>In our lab machines, the &lt;DIMM id, Channel id, Rank id&gt; are determined by higher bits and the addresses in a 4GB region share the same of these ids. Our lab machines have 16 banks, making the &lt;Bank id&gt; a 4-bit value. Each bit in these 4 bits is computed by XORing some of the bits 13-16 with some of the bits 17-20. The bits involved in the derivation of the &lt;Row id&gt; and &lt;Bank id&gt; are listed below and also visualized in the figure.</p> <ul> <li>&lt;Row id&gt;: bits 17-31</li> <li>&lt;Column id&gt;: bits 0-12</li> <li>&lt;Bank id&gt;: (unknown) each bit comes from XORing some of bits 13-16 (the exact number of bits being XORed can range from 0 to 4) with some of bits 17-20</li> </ul> <div style="text-align:center"><img src="figures/rowhammer_xor.png" width="50%" /></div> <p style="color:gray; font-size: 90%; text-align: center;"><em>Physical address bits involved in Row/Bank ID generation</em></p> <blockquote class="discussion-title"> <p>2-1 Discussion Question</p> <p>Given a victim address <code class="language-plaintext highlighter-rouge">0x752C3000</code>, what is the value of its &lt;Row id&gt;? The value of its &lt;Column id&gt;?</p> <p>For this same victim address, when the exact XOR function being used for computing the &lt;Bank id&gt; is unknown, list all possible attacker addresses that stays in the row below the victim address (i.e., the attacker’s &lt;Row id&gt; is 1 more than the victim’s) while sharing the same &lt;Column id&gt; and &lt;Bank id&gt;. Hint: there should be 16 such addresses total.</p> </blockquote> <h3 class="no_toc" id="bank-conflict-side-channel"> <a href="#bank-conflict-side-channel" class="anchor-heading" aria-labelledby="bank-conflict-side-channel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Bank-conflict Side Channel </h3> <p>How can we determine whether two addresses map to the same bank or not without knowing the proprietary XOR function? The answer is to use our favorite tool in 6.5950: timing side channels!</p> <p>As discussed in the lecture, a DRAM bank can only serve one memory request at a time, but multiple accesses to different banks can be served simultaneously, allowing for <em>bank-level</em> parallelism. So, if you issue two memory requests to the same bank back-to-back, one of the requests needs to wait for the other to complete before being served, resulting in longer latency - this is known as a row buffer conflict. In contrast, if the two memory requests target two different banks, they can be served in parallel, resulting in a shorter latency.</p> <p>Here are two possible timing strategies you might consider employing:</p> <ul> <li> <p>Detecting row buffer conflicts: Given two physical addresses x and y, make sure both of the addresses are not cached. First, access address x from DRAM (filling the row buffer with x’s row). Next, access address y from DRAM, which will close the row buffer opened by x if it maps to the same bank. Finally, access address x again from DRAM and measure its access latency (making sure it was flushed from the cache beforehand). If x and y are mapped to the same bank but different rows, then this access will result in a row buffer miss and should take a longer time to complete.</p> </li> <li> <p>Detect bus contention and row buffer conflicts: Given two physical addresses x and y, again make sure both of the addresses are not cached. Access the two addresses back-to-back without memory fences in between and measure their collective access latency. If the two addresses are mapped to the same bank and different rows, they will cause memory bus contention in addition to row buffer conflicts, and thus will result in even longer latency.</p> </li> </ul> <blockquote class="exercise-title"> <p>2-2 Exercise</p> <p>In <code class="language-plaintext highlighter-rouge">src/shared.cc</code> implement <code class="language-plaintext highlighter-rouge">measure_bank_latency</code>, which measures a (potential) bank collision between two addresses. The staff-provided <code class="language-plaintext highlighter-rouge">main</code> function in <code class="language-plaintext highlighter-rouge">part2.cc</code> will call your <code class="language-plaintext highlighter-rouge">measure_bank_latency</code> with two different address pairs. The first address pair will map to the same bank, and the second address pair will map to different banks.</p> </blockquote> <blockquote class="discussion-title"> <p>2-3 Discussion Question</p> <p>Report the statistics produced by your code when running <code class="language-plaintext highlighter-rouge">part2</code>, and describe how you can use the difference in these statistics to distinguish between the pairs. Note that you can toggle between using the <code class="language-plaintext highlighter-rouge">print_results</code> and <code class="language-plaintext highlighter-rouge">print_to_json</code> functions for the final statistical results, and you can toggle the number of <code class="language-plaintext highlighter-rouge">SAMPLES</code>.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-1"> <a href="#submission-and-grading-1" class="anchor-heading" aria-labelledby="submission-and-grading-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Relevant files to submit to GitHub: <code class="language-plaintext highlighter-rouge">src/shared.cc</code></p> <h2 id="part-3-dram-geometry---bank-xor-function-20"> <a href="#part-3-dram-geometry---bank-xor-function-20" class="anchor-heading" aria-labelledby="part-3-dram-geometry---bank-xor-function-20"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 3: DRAM Geometry - Bank XOR-Function (20%) </h2> <h3 id="the-xor-bank-mapping-function"> <a href="#the-xor-bank-mapping-function" class="anchor-heading" aria-labelledby="the-xor-bank-mapping-function"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The XOR Bank Mapping Function </h3> <p>Since you can now determine whether two addresses are mapped to the same bank, you can reverse engineer the bank mapping function by completing the last two steps: 2) collecting a large number of addresses and binning them into multiple groups so that the addresses in the same group are mapped to the same bank; 3) trying all possible bank mapping functions to find one that does not violate your binning results. To make the lab easier, instead of asking you to search the entire possible function space via brute force or perform some form of statistical analysis, we will give you 3 candidate functions and ask you to figure out which one is correct.</p> <p>The 3 candidate functions for constructing the Bank ID are listed below (assuming 0-indexing on an address <code class="language-plaintext highlighter-rouge">A</code>):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F0: {A16 ^ A18, A13 ^ A19, A15 ^ A18, A14 ^ A20}
F1: {A15 ^ A19, A14 ^ A18, A13 ^ A17, A16 ^ A20}
F2: {A13 ^ A18, A14 ^ A17, A16 ^ A19, A15 ^ A20}
</code></pre></div></div> <p>Our approach to solving this is the following</p> <ul> <li>Allocate a large memory region by calling function <code class="language-plaintext highlighter-rouge">allocate_pages</code>.</li> <li>Select many addresses that are mapped uniformly across different rows. You want to be careful with the stride such that you hit the banks uniformly</li> <li>Bin these addresses into 16 groups where each group corresponds to one bank in the function <code class="language-plaintext highlighter-rouge">bin_rows</code>. You will need to use the function <code class="language-plaintext highlighter-rouge">measure_bank_latency</code> and the threshold (the <code class="language-plaintext highlighter-rouge">THRESHOLD</code>) you have derived.</li> <li>Compute the bank ID of all the addresses using each of the candidate functions and check whether the computed bank IDs for the addresses in the same group are consistent or not. We provided most of the statistical analysis code already, but feel free to adjust them if needed. We recommend that you just fine-tune the <code class="language-plaintext highlighter-rouge">CONSISTENCY</code> parameter (more on this later).</li> </ul> <p>If the correct function is chosen, the computed bank ids for the addresses in the same group should be the same. However, there may exist some noise in the binning process, and you may observe that the binning results are not 100% accurate. Therefore, you should check the ratio of addresses that have a consistent bank ID in each group.</p> <p>We define the <em>consistency rate</em> as the proportion of addresses in a bin which map to the most common bank ID in that bin. For instance, if a 4-element bin has addresses mapping to banks [1,1,3,1], the consistency rate of that bin is 75%.</p> <p>Generally, when using the correct mapping function, the consistency rate should be at or above 98%, as around 98% of the addresses in the same group will have the same bank id, with the remaining 2% having different bank ids.</p> <blockquote class="exercise-title"> <p>3-1 Exercise</p> <p>Implement bank ID binning with <code class="language-plaintext highlighter-rouge">bin_rows</code>. The rest of the analysis code is already completed for you, but you can make modifications if you really want to. Make sure that the correct function index is printed in the end.</p> </blockquote> <blockquote class="discussion-title"> <p>3-2 Discussion Question</p> <p>Based on the XOR function you reverse-engineered, determine which of the 16 candidate addresses you derived in Discussion Question 2-1 maps to the same bank.</p> </blockquote> <p>The XOR function can also be reverse-engineered via other types of timing side channels. If curious, you can read <a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_pessl.pdf">DRAMA</a> to see how this can be done.</p> <h3 class="no_toc" id="submission-and-grading-2"> <a href="#submission-and-grading-2" class="anchor-heading" aria-labelledby="submission-and-grading-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Please remove any extra print statements added. We will deduct two points for extra print statements. Do not remove the print statements provided at the start of the lab. Relevant files to submit to GitHub: <code class="language-plaintext highlighter-rouge">src/part3/part3.cc</code></p> <h2 id="part-4-its-rowhammer-time-20"> <a href="#part-4-its-rowhammer-time-20" class="anchor-heading" aria-labelledby="part-4-its-rowhammer-time-20"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 4: It’s Rowhammer Time! (20%) </h2> <p>As we mentioned before, to make Rowhammer work, we need to manipulate addresses to go through two translation steps: Virtual Address → Physical Address → DRAM Coordinates. The previous part of the lab teaches you on how to reverse engineer the second translation step. In the real world, you would then utilize that to start finding victim and attacker rows. However, in past years, we find that students experience a lot of instability and unnecessary grunt work when sent off to discover their own addresses. To save your efforts, we have pre-profiled the lab machines and located victim and attacker rows, and we directly provide the physical addresses of the startings of these rows to you (see table below, as well as file <code class="language-plaintext highlighter-rouge">src/part4/part4.cc</code>). With these information, you can use your reverse page table <code class="language-plaintext highlighter-rouge">PPN_VPN_map</code> to find the corresponding virtual addresses. Your task in this part is to implement a double-sided Rowhammer attack and try the attack on these addresses.</p> <div class="table-wrapper"><table> <thead> <tr> <th>Victim</th> <th>Row Above (A)</th> <th>Row Below (B)</th> <th>Distant Row (C)</th> <th>Same Row ID, Diff. Bank (D)</th> </tr> </thead> <tbody> <tr> <td>0x75380000</td> <td>0x753A2000</td> <td>0x7536E000</td> <td>0x75308000</td> <td>0x75382000</td> </tr> </tbody> </table></div> <h3 class="no_toc" id="attack-outline"> <a href="#attack-outline" class="anchor-heading" aria-labelledby="attack-outline"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Attack Outline </h3> <p>You will implement the Rowhammer attack strategy inside the <code class="language-plaintext highlighter-rouge">hammer_addresses</code> function (in <code class="language-plaintext highlighter-rouge">src/part4/part4.cc</code>). The <code class="language-plaintext highlighter-rouge">main</code> function (in <code class="language-plaintext highlighter-rouge">part4.cc</code>) contains code to call your <code class="language-plaintext highlighter-rouge">hammer_addresses</code> function to perform the attack, collect statistics and report the number of observed bitflips. You should not modify the <code class="language-plaintext highlighter-rouge">main</code> function.</p> <p>Getting Rowhammer to work can be quite tricky. When writing your code in C/C++, you have to think very carefully about what DRAM operations will be triggered by the code and what cells are being accessed with your code. For our specific DRAM configuration, a row is of size 2^13 = 8KB and its physical address is aligned at 8KB.</p> <p>Here is a high-level description of the attack you will implement.</p> <ol> <li><strong>Prime</strong> the victim and attacker rows. Set the victim row to all 0’s, and set the attacker rows to all 1’s. <ul> <li>Theoretically, Rowhammer works when we access neighboring rows with a specific pattern and should work regardless of the content inside the attacker and victim rows. However, according to <a href="https://people.inf.ethz.ch/omutlu/pub/Revisiting-RowHammer_isca20-FINAL-DO-NOT_DISTRIBUTE.pdf">prior work</a>, setting the attacker’s rows to all 1’s and victim’s row to all 0’s can result in a higher probability of triggering bitflips.</li> <li>When priming rows, ensure that you’re writing the values to the entire row, and not priming outside of row boundaries. If you’re observing bit-flips in your victim row 100% of the time, it is likely that you accidentally wrote 1’s to the victim row when you meant to prime the attacker row.</li> </ul> </li> <li><strong>Hammer</strong> two rows, repeatedly alternatively accessing two attack rows in DRAM 5 million times. <ul> <li>To access a row, you only need to access one address belonging to that row. Think about how the row buffer works.</li> <li>Once you access a row, it will be fetched in the cache and later accesses will hit the cache. Thus, you will need to come up with a way to ensure that accesses to these two rows always reach DRAM.</li> </ul> </li> <li><strong>Probe</strong> the victim row, compare the read results with the primed values (aka, all 0’s), and check whether any bit in the row has been flipped to a 1. <ul> <li>It can be tricky to determine whether a bitflip is observed due to an implementation bug or the actual Rowhammer effect. You should test your code to make sure that without the hammering step (e.g., only priming), the probe observes no bitflips.</li> </ul> </li> </ol> <blockquote class="exercise-title"> <p>4-1 Exercise</p> <p>Complete the <code class="language-plaintext highlighter-rouge">hammer_addresses</code> function in <code class="language-plaintext highlighter-rouge">src/part4/part4.cc</code>.</p> <p>The <code class="language-plaintext highlighter-rouge">main</code> function in <code class="language-plaintext highlighter-rouge">part4.cc</code> will use <code class="language-plaintext highlighter-rouge">hammer_addresses</code> to hammer 3 attacker row pairs (i.e., A/B, A/C, and A/D, the address of A, B, C, and D are showned in the table above) 100x, and report how often the attack succeeds (i.e. observes at least one bit flip in the victim row).</p> </blockquote> <blockquote class="hint"> <p>If you setup rowhammer correctly, you should achieve an extremely high rate of bitflips for one hammering configuration. If you aren’t experiencing this, consider that you might have to <em>clean up something in the memory hierarchy</em> after the priming step.</p> </blockquote> <blockquote class="discussion-title"> <p>4-2 Discussion Question</p> <p>Include the bitflip observation statistics in the table below. Then answer the following questions:</p> <p>Do your results match your expectations? Why might some attacker pairings result in more flips than others? Do you expect any of the pairs to <em>never</em> cause a flip?</p> <div class="table-wrapper"><table> <thead> <tr> <th>Hammering Pairs</th> <th>A/B</th> <th>A/C</th> <th>A/D</th> </tr> </thead> <tbody> <tr> <td>Number of Successes (100 trials)</td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table></div> </blockquote> <h3 class="no_toc" id="submission-and-grading-3"> <a href="#submission-and-grading-3" class="anchor-heading" aria-labelledby="submission-and-grading-3"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Relevant files to submit to GitHub: <code class="language-plaintext highlighter-rouge">src/part4/part4.cc</code>.</p> <h2 id="part-5-mitigation-using-error-correcting-codes-30"> <a href="#part-5-mitigation-using-error-correcting-codes-30" class="anchor-heading" aria-labelledby="part-5-mitigation-using-error-correcting-codes-30"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 5: Mitigation using Error Correcting Codes (30%) </h2> <p>Now that we’ve learned how to cause bit-flips in the wild, let’s now explore a potential defense to Rowhammer: Error Correcting Codes (ECC). Error correcting codes, as the name suggested, can help correct errors. More precisely, they are encoding schemes that add redundancy to stored data and use the redundancy to detect and correct errors when they occur. There exist variety of ECCs with different capabilities and storage overhead.</p> <p class="warning-title">For this part, you do not need to use condor. You can run your code on the unicorn server or simply on your own machine by directly running <code class="language-plaintext highlighter-rouge">cd bin</code> and <code class="language-plaintext highlighter-rouge">./part5</code>. <code class="language-plaintext highlighter-rouge">libverif.so</code> will be used for verifying your solutions again. Note that you must run it inside the <code class="language-plaintext highlighter-rouge">bin</code> directory, otherwise there would be an error while loading shared libraries.</p> <h3 id="understanding-ecc-types-and-design-choices"> <a href="#understanding-ecc-types-and-design-choices" class="anchor-heading" aria-labelledby="understanding-ecc-types-and-design-choices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Understanding ECC: Types and Design Choices </h3> <p>We study the three most commonly seen ECCs.</p> <ul> <li><strong>Repetition Codes</strong>: The simplest code is the <em>repetition code</em>, which duplicates each bit in the data multiple times. <ul> <li>Examples: a 2-repetition code protecting the value <code class="language-plaintext highlighter-rouge">1011</code> is stored as <code class="language-plaintext highlighter-rouge">1011 1011</code>, and a 3-repetition code would be stored as <code class="language-plaintext highlighter-rouge">1011 1011 1011</code>.</li> <li>Error detection: straightforward.</li> </ul> </li> <li><strong>Single Parity Bit</strong>: If we’re concerned about storage overhead, we can detect errors by calculating the <strong>parity</strong> of the data by XORing the data bits together. <ul> <li>Examples: the parity bit for <code class="language-plaintext highlighter-rouge">1011</code> is <code class="language-plaintext highlighter-rouge">1</code>, and the parity bit for <code class="language-plaintext highlighter-rouge">1001</code> is <code class="language-plaintext highlighter-rouge">0</code>.</li> <li>Error detection: A single bit flip in the data results in the parity bit changing. To detect bit flips, we can re-calculate the corrupted data’s parity and compare it against the previously calculated parity bit stored with the data. If more than one bit flips, this scheme may or may not detect it.</li> </ul> </li> <li><strong>Hamming Codes</strong>: Hamming codes use <em>multiple</em> parity bits to deal with bit errors. Given a scheme protecting N bits with K parity bits, we call it Hamming(N+K, N). <ul> <li>Examples: The most common Hamming code is Hamming(7,4), i.e., 4 data bits protected by 3 parity bits. A graphical depiction of the parity encoding (p<sub>1</sub> to p<sub>3</sub>) for the 4 data bits (d<sub>1</sub> to d<sub>4</sub>) is shown below. As indicated by the green circle, the first parity bit p<sub>1</sub> considers the parity of data bits 1, 2, and 4, and is calculated by XORing d<sub>1,2,4</sub> together. Similarly, the purple circle indicates that the second parity bit p<sub>2</sub> is calculated by XORing d<sub>1,3,4</sub>. You can infer how the last parity bit p<sub>2</sub> is calculated from the red circle.</li> <li>Error detection: Within each circle, we can perform the same parity check as in the “Single Parity Bit” scheme. By using parity bits in such an overlapping fashion, the Hamming(7,4) code can detect one or two bit flips (even though it cannot tell exactly how many bits flip). By assuming only one bit flips, it can further correct it.</li> </ul> <div style="text-align:center"><img src="figures/rowhammer_hamming.png" width="40%" /></div> <p style="color:gray; font-size: 80%; text-align: center;"><em>Hamming(7,4) Code Example (<a href="https://en.wikipedia.org/wiki/Hamming(7,4)#/media/File:Hamming(7,4).svg">Source</a>)</em></p> </li> </ul> <blockquote class="discussion-title"> <p>5-1 Discussion Question</p> <p>Given the ECC type descriptions listed above, fill in the following table (assuming a data length of 4). For detection/correction, answer “X” only if it can <strong>always</strong> detect/correct X number of errors, with no corner case exceptions. For detecting more than 1 error, the scheme is not required to tell exactly how many errors exist. We’ve filled in the first column for you.</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>1-Repetition (No ECC)</th> <th>2-Repetition</th> <th>3-Repetition</th> <th>Single Parity Bit</th> <th>Hamming(7,4)</th> </tr> </thead> <tbody> <tr> <td><strong>Code Rate (Data Bits / Total Bits)</strong></td> <td>1.0</td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td><strong>Max Number of Errors Can Detect</strong></td> <td>0</td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td><strong>Max Number of Errors Can Correct</strong></td> <td>0</td> <td> </td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table></div> </blockquote> <h3 id="implementing-ecc-hamming2216"> <a href="#implementing-ecc-hamming2216" class="anchor-heading" aria-labelledby="implementing-ecc-hamming2216"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Implementing ECC: Hamming(22,16) </h3> <p>Let’s try to implement a Hamming coded ECC that is used in <a href="https://docs.xilinx.com/v/u/en-US/xapp383">real hardware</a> for protecting DRAMs. These ECCs are introduced primarily to defend against <a href="https://en.wikipedia.org/wiki/Soft_error">soft errors</a>. Hamming(22,16) can correct single errors and detect double errors (SECDED). It uses six parity bits (P0-P5) to protect sixteen data bits (D0-D15). The equations for the first five parity bits (P0-P4) are shown below (and also described on Page 2 of this <a href="https://docs.xilinx.com/v/u/en-US/xapp383">hardware documentation</a>).</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P0 = D15 ⊕ D13 ⊕ D11 ⊕ D10 ⊕ D8 ⊕ D6 ⊕ D4 ⊕ D3 ⊕ D1 ⊕ D0
P1 = D13 ⊕ D12 ⊕ D10 ⊕ D9 ⊕ D6 ⊕ D5 ⊕ D3 ⊕ D2 ⊕ D0
P2 = D15 ⊕ D14 ⊕ D10 ⊕ D9 ⊕ D8 ⊕ D7 ⊕ D3 ⊕ D2 ⊕ D1
P3 = D10 ⊕ D9 ⊕ D8 ⊕ D7 ⊕ D6 ⊕ D5 ⊕ D4
P4 = D15 ⊕ D14 ⊕ D13 ⊕ D12 ⊕ D11
</code></pre></div></div> <p>The last parity bit, P5, protects both the data and the other parity bits, and is computed by XOR-ing all of the data bits (D0-D15) and the other parity bits (P0-P4). We refer to P5 as the overall parity bit.</p> <p>To start, implement the parity encoding operation in <code class="language-plaintext highlighter-rouge">src/part5/part5.cc</code>.</p> <p>For your convenience, we’ve provided the following helper types/functions in <code class="language-plaintext highlighter-rouge">src/ecc.hh</code>:</p> <ul> <li><code class="language-plaintext highlighter-rouge">struct hamming_struct</code>: A C++ struct which contains a data and parity pair. The bit 0 (i.e., lowest bit) of data is D0, the bit 1 of data is D1, … The bit 0 of parity is P0, the bit 1 of parity is P1, …</li> <li><code class="language-plaintext highlighter-rouge">struct hamming_result</code>: Stores an error type (one of <code class="language-plaintext highlighter-rouge">NO_ERROR</code>/<code class="language-plaintext highlighter-rouge">SINGLE_ERROR</code>/<code class="language-plaintext highlighter-rouge">DOUBLE_ERROR</code>/<code class="language-plaintext highlighter-rouge">PARITY_ERROR</code>) and computed syndrome (explained later).</li> <li><code class="language-plaintext highlighter-rouge">getBit(data, pos)</code>: Returns the value of the bit at position <code class="language-plaintext highlighter-rouge">pos</code> within <code class="language-plaintext highlighter-rouge">data</code>.</li> <li><code class="language-plaintext highlighter-rouge">flipBit(data, pos)</code>: Flips the bit at position <code class="language-plaintext highlighter-rouge">pos</code> within <code class="language-plaintext highlighter-rouge">data</code>.</li> <li><code class="language-plaintext highlighter-rouge">isParityBit(bitNum)</code>: Returns whether bitNum corresponds to a parity bit in the Hamming(22,16) encoding.</li> <li><code class="language-plaintext highlighter-rouge">extractEncoding(encoded)</code>: Takes a 22-bit encoded ECC value, and extracts the parity and data bits (returned in a <code class="language-plaintext highlighter-rouge">hamming_struct</code>).</li> <li><code class="language-plaintext highlighter-rouge">embedEncoding(hamming_struct)</code>: Takes in a <code class="language-plaintext highlighter-rouge">hamming_struct</code> and returns the combined ECC value.</li> <li><code class="language-plaintext highlighter-rouge">parity_eqs</code> array in <code class="language-plaintext highlighter-rouge">part5.cc</code>: Describes the parity equations in an array representation.</li> </ul> <blockquote class="exercise-title"> <p>5-2 Exercise</p> <p>Complete <code class="language-plaintext highlighter-rouge">genParity()</code> to calculate the parity bits (P0-P5) for an input piece of data that needs protection. You should see a message telling you that your parity value is correct when you run <code class="language-plaintext highlighter-rouge">./bin/part5</code> (make sure to compile your implementation using <code class="language-plaintext highlighter-rouge">make</code>!).</p> </blockquote> <p>Now, let’s consider how error detection and error correction are performed in Hamming(22,16). Given a single-bit error, Hamming(22,16) can detect whether the error has happened and locate the bit that has been flipped. Basically, taking a piece of 22-bit value with Hamming(22,16) protection, we can compute something called a <em>syndrome</em>. The encoding scheme is designed so that <strong>the syndrome corresponds to the location of the single error</strong>.</p> <p>The syndrome is computed by XORing two 5-bit values. The first is the “extracted parity bits” P0-P4 stored in the 22-bit value. The second is the “reconstructed parity bits” P0-P4 from the data bits D0-D15. In addition, an overall parity bit is computed by XORing all 22 bits together. Based on the syndrome and overall parity bit, Hamming(22,16) can detect and correct bit flips in both the data bits and the parity bits. See the table below for detailed information.</p> <div class="table-wrapper"><table> <tbody> <tr> <td><strong>Syndrome</strong></td> <td><strong>Overall Parity</strong></td> <td><strong>Error Type</strong></td> <td><strong>Notes</strong></td> </tr> <tr> <td>0</td> <td>0</td> <td>No Error</td> <td> </td> </tr> <tr> <td>!=0</td> <td>1</td> <td>Single Error</td> <td>Correctable. Syndrome holdes incorrect bit position.</td> </tr> <tr> <td>!=0</td> <td>0</td> <td>Double Error</td> <td>Uncorrectable.</td> </tr> <tr> <td>0</td> <td>1</td> <td>P5 Error</td> <td>P5 is in error and can be corrected.</td> </tr> </tbody> </table></div> <blockquote class="discussion-title"> <p>5-3 Discussion Question</p> <p>When a single bit flip is detected, describe what action should be conducted to correct this error with Hamming(22,16).</p> </blockquote> <p>With all the information above, let’s complete the function <code class="language-plaintext highlighter-rouge">findHammingErrors()</code> which takes in an encoded ECC value and determines whether there is an error. This function should return the error type and the syndrome.</p> <p>Finally, complete the function <code class="language-plaintext highlighter-rouge">verifyAndRepair()</code> which uses the information gained from <code class="language-plaintext highlighter-rouge">findHammingErrors()</code> to determine a good course of action. If there is no error, or an unrecoverable error, <code class="language-plaintext highlighter-rouge">verifyAndRepair()</code> should return the original value. If there is a single bit error (including parity errors), <code class="language-plaintext highlighter-rouge">verifyAndRepair()</code> returns the data with the error corrected.</p> <blockquote class="exercise-title"> <p>5-4 Exercise</p> <p>Complete <code class="language-plaintext highlighter-rouge">findHammingErrors()</code> and <code class="language-plaintext highlighter-rouge">verifyAndRepair()</code>. You should see <code class="language-plaintext highlighter-rouge">All tests passed!</code> reported.</p> </blockquote> <blockquote class="discussion-title"> <p>5-5 Discussion Question</p> <p>Can the Hamming(22,16) code we implemented always protect us from rowhammer attacks? If not, describe how a clever attacker could work around this scheme.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-4"> <a href="#submission-and-grading-4" class="anchor-heading" aria-labelledby="submission-and-grading-4"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Your <code class="language-plaintext highlighter-rouge">src/part5/part5.cc</code> will be graded automatically, checked against 5 random inputs. As always, submit your discussion questions as a PDF to Gradescope.</p> <h2 id="behind-the-scene-how-this-lab-infrastructure-was-developed"> <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed" class="anchor-heading" aria-labelledby="behind-the-scene-how-this-lab-infrastructure-was-developed"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Behind the Scene: How this lab infrastructure was developed? </h2> <p>As you have seen in Part 1, using the virtual to physical addresses mapping information provided by Linux’s <code class="language-plaintext highlighter-rouge">pagemap</code> interface is a critial step to make the rowhammer attack work. Without a surprise, this interface has been banned from non-sudo users since Linux 4.0 (released in 2015), as a quick countermeasure against rowahmmer attacks. However, throughout the lab, you are never granted sudo permission on the machine. Then how did you smoothly access this interface during the lab?</p> <p>This comes from our special setups on the machines: A special kernel module is installed to bypass this permission check. The source code of it can be found in <code class="language-plaintext highlighter-rouge">driver</code> folder of the starter code of the lab. And we would be happy to give you a tour on how it is developed – how we navigate through the linux source code, identify the location of the permission check of <code class="language-plaintext highlighter-rouge">pagemap</code> interface, and hijack the checking result.</p> <p>Per <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt">documentation</a>, one requires <code class="language-plaintext highlighter-rouge">CAP_SYS_ADMIN</code> capabilities on Linux to access <code class="language-plaintext highlighter-rouge">/proc/self/pagemap</code>. We found this permission check located at Line 1624 of <code class="language-plaintext highlighter-rouge">fs/proc/task_mmu.c</code> file in Linux v5.15.97 source code (<a href="https://elixir.bootlin.com/linux/v5.15.97/source/fs/proc/task_mmu.c#L1624">code here</a>). The code does the permission check using <code class="language-plaintext highlighter-rouge">file_ns_capable</code> function and saves the checking result in the <code class="language-plaintext highlighter-rouge">show_pfn</code> field of the <code class="language-plaintext highlighter-rouge">pm</code> variable (whose type is <code class="language-plaintext highlighter-rouge">struct pagemapread</code>).</p> <p>How to force this check to always return <code class="language-plaintext highlighter-rouge">true</code>? We could change the Linux source code and recompile it, but we do not want to – It is too muddy to config our lab machines with a Linux kernel fully compiled by ourselves. Instead, we developed the <code class="language-plaintext highlighter-rouge">rh_driver</code> kernel module to solve this problem, which can be installed to or uninstalled from Linux easily, while the machine is on. It uses a Linux feature known as <a href="https://docs.kernel.org/trace/kprobes.html">kprobes</a>, which allows one to “dynamically break into any kernel routine and collect debugging and performance information non-disruptively”. If we break at when the <code class="language-plaintext highlighter-rouge">file_ns_capable</code> function returns, we can change the return value to bypass the permission check. We use two kprobes to achieve this:</p> <ul> <li> <p>The first kprobe (<code class="language-plaintext highlighter-rouge">file_ns_capable_pre</code> function in <code class="language-plaintext highlighter-rouge">driver/rh_driver.c</code>) determines whether <code class="language-plaintext highlighter-rouge">file_ns_capable</code> function is called for the permission check specifically for our <code class="language-plaintext highlighter-rouge">pagemap</code> interface (i.e., is called from Line 1624 of <code class="language-plaintext highlighter-rouge">fs/proc/task_mmu.c</code>). It checks whether the return address on the stack is within a threshold range to <code class="language-plaintext highlighter-rouge">pagemap_read</code> function and whether the second and third arguments match the code from source. We think this heuristic is good enough. If this check pass, we insert the second kprobe.</p> </li> <li> <p>The second kprobe (<code class="language-plaintext highlighter-rouge">target_post</code> function in <code class="language-plaintext highlighter-rouge">driver/rh_driver.c</code>) modifies the return of <code class="language-plaintext highlighter-rouge">file_ns_capable</code> function to be <code class="language-plaintext highlighter-rouge">true</code>.</p> </li> </ul> <p>Finally, now you can access <code class="language-plaintext highlighter-rouge">/proc/self/pagemap</code> without any additional privileges – exciting for us as course staff, though perhaps less exciting for a student in computer security class.</p> <h2 class="no_toc" id="acknowledgements"> <a href="#acknowledgements" class="anchor-heading" aria-labelledby="acknowledgements"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgements </h2> <p>Contributors: Peter Deutsch, Miguel Gomez-Garcia, Mengjia Yan, William Liu.</p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
