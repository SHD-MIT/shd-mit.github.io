<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2024/assets/css/just-the-docs-default.css"> <script src="/2024/assets/js/vendor/lunr.min.js"></script> <script src="/2024/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>CPU Fuzzing | 6.5950/6.5951</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="CPU Fuzzing" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Secure Hardware Design" /> <meta property="og:description" content="Secure Hardware Design" /> <meta property="og:site_name" content="6.5950/6.5951" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="CPU Fuzzing" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Secure Hardware Design","headline":"CPU Fuzzing","url":"/2024/labs/fuzz.html"}</script> <!-- End Jekyll SEO tag --> <!-- Cover up the page while CSS is loading to prevent flicker --> <div id="preload-cover"></div> <style> #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#fff; z-index:9999; } @media (prefers-color-scheme: dark) { #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#222326; z-index:9999; } } </style> <script> window.addEventListener('load', function() { var cover = document.getElementById('preload-cover'); cover.style.display = 'none'; }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Feather. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/2024/" class="site-title lh-tight"> 6.5950/6.5951 </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/2024/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2024/calendar.html" class="nav-list-link">Calendar</a></li><li class="nav-list-item"><a href="/2024/lectureReadings.html" class="nav-list-link">Lecture Readings</a></li><li class="nav-list-item"><a href="/2024/paperDiscussion.html" class="nav-list-link">Paper Discussion</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Recitations category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/recitations.html" class="nav-list-link">Recitations</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/recitations/cpp.html" class="nav-list-link">CTF of C Programming</a></li><li class="nav-list-item "><a href="/2024/recitations/physical.html" class="nav-list-link">CTF of Physical Attacks</a></li><li class="nav-list-item "><a href="/2024/recitations/riscv.html" class="nav-list-link">Binary Exploitation and RISC-V Warmup</a></li><li class="nav-list-item "><a href="/2024/recitations/formal.html" class="nav-list-link">Formal Verification</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/labs.html" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/labs/fingerprinting.html" class="nav-list-link">Website Fingerprinting</a></li><li class="nav-list-item "><a href="/2024/labs/cache.html" class="nav-list-link">Cache Attacks</a></li><li class="nav-list-item "><a href="/2024/labs/spectre.html" class="nav-list-link">Spectre Attacks</a></li><li class="nav-list-item "><a href="/2024/labs/rowhammer.html" class="nav-list-link">Rowhammer</a></li><li class="nav-list-item "><a href="/2024/labs/aslr.html" class="nav-list-link">ASLR Bypasses</a></li><li class="nav-list-item "><a href="/2024/labs/psp.html" class="nav-list-link">Pretty Secure Processor</a></li><li class="nav-list-item active"><a href="/2024/labs/fuzz.html" class="nav-list-link active">CPU Fuzzing</a></li><li class="nav-list-item "><a href="/2024/labs/formal.html" class="nav-list-link">CPU Verification</a></li></ul></li><li class="nav-list-item"><a href="/2024/paperReadingGuidance.html" class="nav-list-link">Paper Readings Guidance</a></li><li class="nav-list-item"><a href="/2024/forInstructors.html" class="nav-list-link">For Instructors</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search 6.5950/6.5951" aria-label="Search 6.5950/6.5951" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/2024/labs.html">Labs</a></li> <li class="breadcrumb-nav-list-item"><span>CPU Fuzzing</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <script> function ColorCorrect() { const theme = jtd.getTheme(); if (theme == "dark") { document.getElementById("figure1").src = "figures/fuzz-figure1-dark.png"; document.getElementById("figure2").src = "figures/fuzz-figure2-dark.png"; document.getElementById("figure3").src = "figures/fuzz-figure3-dark.png"; } else { document.getElementById("figure1").src = "figures/fuzz-figure1.png"; document.getElementById("figure2").src = "figures/fuzz-figure2.png"; document.getElementById("figure3").src = "figures/fuzz-figure3.png"; } } document.addEventListener('DOMContentLoaded', function () { ColorCorrect(); }, false); </script> <h1 class="no_toc" id="cpu-fuzzing-lab"> <a href="#cpu-fuzzing-lab" class="anchor-heading" aria-labelledby="cpu-fuzzing-lab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> CPU Fuzzing Lab </h1> <p><strong>Due Date: May 7</strong>; Last Updated Date: Apr 3</p> <h2 class="no_toc" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h2> <ul id="markdown-toc"> <li><a href="#overview-pretty-secure-processor" id="markdown-toc-overview-pretty-secure-processor">Overview: Pretty Secure Processor</a></li> <li><a href="#part-1-mystery-of-the-faulty-cpu-10" id="markdown-toc-part-1-mystery-of-the-faulty-cpu-10">Part 1: Mystery of the Faulty CPU (10%)</a></li> <li><a href="#part-2-fuzzing-for-faulty-inputs-30" id="markdown-toc-part-2-fuzzing-for-faulty-inputs-30">Part 2: Fuzzing for Faulty Inputs (30%)</a></li> <li><a href="#part-3-fuzzing-for-a-hidden-cpu-backdoor-45" id="markdown-toc-part-3-fuzzing-for-a-hidden-cpu-backdoor-45">Part 3: Fuzzing for a Hidden CPU Backdoor (45%)</a></li> <li><a href="#part-4-using-the-backdoor-to-exploit-a-remote-system-15" id="markdown-toc-part-4-using-the-backdoor-to-exploit-a-remote-system-15">Part 4: Using the Backdoor to Exploit a Remote System (15%)</a></li> <li><a href="#part-5-bug-bounty-optional-10-bonus" id="markdown-toc-part-5-bug-bounty-optional-10-bonus">Part 5: Bug Bounty (Optional, 10% Bonus)</a></li> <li><a href="#part-6-challenge-problem-optional-no-credit" id="markdown-toc-part-6-challenge-problem-optional-no-credit">Part 6: Challenge Problem (Optional, No Credit)</a></li> </ul> <h2 class="no_toc" id="lab-details"> <a href="#lab-details" class="anchor-heading" aria-labelledby="lab-details"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lab Details </h2> <h3 class="no_toc" id="collaboration-policy"> <a href="#collaboration-policy" class="anchor-heading" aria-labelledby="collaboration-policy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Collaboration Policy </h3> <p>Our full Academic Honesty policy can be found on the <a href="../index.html#collaboration-policy">Course Information page</a> of our website. As a reminder, all 6.5950/6.5951 labs should be completed individually. You may discuss the lab at a high level with a classmate, but you may not work on code together or share any of your code.</p> <h3 class="no_toc" id="getting-started"> <a href="#getting-started" class="anchor-heading" aria-labelledby="getting-started"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h3> <p>Log in to our lab machine with <code class="language-plaintext highlighter-rouge">ssh username@unicorn.csail.mit.edu</code>. The username and initial password are the same as previous labs, though you should have changed your password on unicorn (when you use it as a jumper) in previous labs. We will not email you again about this information but feel free to ask TA if you forget it.</p> <p>We are using <code class="language-plaintext highlighter-rouge">git</code> for all the labs – instructions for setting up the git repository can be found on the <a href="../labs.html#github">labs page</a>.</p> <p>In addition to submitting code, you are required to submit a PDF lab report containing your answers to Discussion Questions to <a href="https://www.gradescope.com/courses/715149">gradescope</a>. We provide a markdown template in the starter code (<code class="language-plaintext highlighter-rouge">report.md</code>).</p> <h2 class="no_toc" id="warning-start-early"> <a href="#warning-start-early" class="anchor-heading" aria-labelledby="warning-start-early"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Warning: Start Early! </h2> <p>This lab is a potpourri of many systems level programming tasks, including writing low-level RISC-V assembly and C and automating tasks with Python. As there are a large number of open-ended things to do in this lab, we highly encourage you start early on this one.</p> <h1 id="overview-pretty-secure-processor"> <a href="#overview-pretty-secure-processor" class="anchor-heading" aria-labelledby="overview-pretty-secure-processor"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Overview: Pretty Secure Processor </h1> <p><img src="figures/fuzz-banner.png" /></p> <p>In this lab we will explore utilizing CPU fuzzing techniques to discover RTL bugs in a pipelined RISC-V CPU. Specifically, we will be executing all of our attacks on a modified version of <a href="https://github.com/jprx/pretty-secure-processor">Pretty Secure Processor</a>, a CPU designed by your CA Joseph. This modified CPU was custom built specifically for this lab.</p> <p><a href="./psp.html">This page</a> contains a complete description of the PSP platform – we <strong>highly</strong> encourage you to refer to it. Specifically, the sections on CSRs and serial IO will be useful.</p> <h2 class="no_toc" id="what-am-i-building-in-this-lab"> <a href="#what-am-i-building-in-this-lab" class="anchor-heading" aria-labelledby="what-am-i-building-in-this-lab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What am I building in this lab? </h2> <!-- Throughout this lab you will inspect different CPU bugs from two perspectives- the **fuzzing** and **formal** verification perspectives. In the fuzzing sections, you will understand the bug behavior and write C/ assembly code to test the hardware for the presence of a bug. In the formal verification sections, you will implement formal verification rules to find bugs in the CPU RTL. --> <p>In this lab you will implement a number of low-level CPU tasks in C and RISC-V assembly to build a CPU fuzzing engine. <!-- You will be writing C and RISC-V assembly to communicate with the simulated hardware and handle exceptions. --> <!-- Understanding in detail the RISC-V privileged ISA will be important in several parts of the lab. Understanding the C calling convention is also important for interoperating between C and RISC-V assembly code. --></p> <p>Your code will run on the simulated CPU bare metal. That is, you have complete control of the hardware, and your code runs <strong>inside</strong> the CPU being tested. Your job is to write code that tests the hardware and reliably reports whether the hardware (which may have CPU bugs) is operating correctly or not. <!-- In these parts, we treat the CPU as a black box. --> <!-- In the formal part, you will implement Rosette code to read in the CPU RTL SystemVerilog specification, and determine whether it is compliant to the specification or not. This code does not run inside the CPU, but rather **inspects** the CPU being tested. In these parts, we treat the CPU as a white box. --></p> <p>At the end of the lab, you will use the CPU bugs you have discovered and the knowledge of return-oriented programming from the ASLR lab to build an end-to-end exploit on a remote Pretty Secure Processor.</p> <h2 class="no_toc" id="what-happens-when-i-run-my-code"> <a href="#what-happens-when-i-run-my-code" class="anchor-heading" aria-labelledby="what-happens-when-i-run-my-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What happens when I run my code? </h2> <p>All of your lab code runs on Pretty Secure Processor, a 5-stage pipelined RISC-V CPU. When your code is built, we send it to a cycle-accurate simulated Pretty Secure Processor core and let it run. <!-- That is, all of your lab code for this lab will run on a simulated CPU. --></p> <p>By “simulated”, we mean that the RTL (the SystemVerilog that defines the CPU) itself is simulated in a cycle-accurate simulator. Your code is not running in an emulator (like Qemu) nor an ISA simulator – we are simulating everything down to the cycle level! That means that microarchitectural properties like pipelining, hazard forwarding, etc., are all in play for this lab. <!-- In some parts, you may need to write your code to deal with these implementation details. --></p> <!-- As the simulator is fully custom, we have complete transparency into the state of the CPU, and we provide you a robust debugging interface that will allow you to fully trace your code through the CPU. --> <p><img src="https://raw.githubusercontent.com/jprx/pretty-secure-processor/master/images/psp_datapath.png" /> <em>The entire CPU pipeline is simulated at a cycle accurate level: no emulation here!</em></p> <p>(Note that this diagram is for demonstrative purposes only and does not show the entire pipeline. You do not need to understand this diagram in detail, it is provided purely to illustrate the core from a bird’s eye view).</p> <h2 class="no_toc" id="running-your-code"> <a href="#running-your-code" class="anchor-heading" aria-labelledby="running-your-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Running your code </h2> <p>From the top directory of the lab code, there are two scripts – <code class="language-plaintext highlighter-rouge">run.sh</code> and <code class="language-plaintext highlighter-rouge">gdb.sh</code>. To run a given part, first <code class="language-plaintext highlighter-rouge">cd</code> into the part and compile it with <code class="language-plaintext highlighter-rouge">make</code>. You will need to rebuild each part with <code class="language-plaintext highlighter-rouge">make</code> whenever you change any of the code.</p> <p>Then, from the lab root directory, you can run a given part with <code class="language-plaintext highlighter-rouge">./run.sh partX</code>.</p> <h3 class="no_toc" id="adding-code"> <a href="#adding-code" class="anchor-heading" aria-labelledby="adding-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Adding Code </h3> <p>Our <code class="language-plaintext highlighter-rouge">Makefile</code> will automatically build and link any extra files you create. You can create new C files with the <code class="language-plaintext highlighter-rouge">.c</code> extension and assembly source files with the <code class="language-plaintext highlighter-rouge">.s</code> extension. There is one restriction that you cannot create two files having the same name but one has <code class="language-plaintext highlighter-rouge">.c</code> and the other has <code class="language-plaintext highlighter-rouge">.s</code> extension, e.g., <code class="language-plaintext highlighter-rouge">fuzz.c</code> and <code class="language-plaintext highlighter-rouge">fuzz.s</code>.</p> <p>Note that for symbols to be exported from an assembly file they need to be marked <code class="language-plaintext highlighter-rouge">.global</code>.</p> <h3 class="no_toc" id="debug-mode"> <a href="#debug-mode" class="anchor-heading" aria-labelledby="debug-mode"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Debug Mode </h3> <p>To enable debug mode, edit <code class="language-plaintext highlighter-rouge">debug.sh</code> and fill in <code class="language-plaintext highlighter-rouge">SHD_DEBUG_PORT</code> with the debug port that was emailed to you.</p> <p>Then, you can add <code class="language-plaintext highlighter-rouge">--debug</code> to the end of the <code class="language-plaintext highlighter-rouge">run.sh</code> invocation to start debug mode.</p> <p>You should see something like the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>part1 <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ..
<span class="nv">$ </span>./run.sh part1 <span class="nt">--debug</span>
Waiting <span class="k">for </span>debugger on port XXXX...
</code></pre></div></div> <p>You can now open a new terminal window and run <code class="language-plaintext highlighter-rouge">gdb.sh</code>.</p> <p>You should see <code class="language-plaintext highlighter-rouge">Debugger attached!</code> printed in the original terminal, and GDB should give you a session like the following:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./gdb.sh
...
Remote debugging using localhost:XXXX
start <span class="o">()</span> at bringup.s:44
44      la x1, exception_handler_entry
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></div></div> <p>Now you are in a GDB session running on PSP. You can set breakpoints, inspect registers, and step through the assembly to see how your code is behaving. In case you have forgotten the GDB commands, you can refer to the RISC-V System Programming Recitation cheat sheet (link will be available later).</p> <h1 id="part-1-mystery-of-the-faulty-cpu-10"> <a href="#part-1-mystery-of-the-faulty-cpu-10" class="anchor-heading" aria-labelledby="part-1-mystery-of-the-faulty-cpu-10"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1: Mystery of the Faulty CPU (10%) </h1> <p>Congratulations! You landed your dream job as a CPU design engineer at the Pear Computer Company. Your manager has tasked you with using Pretty Secure Processor as the CPU for the next Pear Phone Pro.</p> <p><img src="https://static.wikia.nocookie.net/icarly/images/a/aa/JieanRnR_Cellphone.jpg" /></p> <p><em>The PearPhone Pro</em></p> <p>You sent an early version of your phone out to the Maps test team so they could test the navigation algorithms. To your surprise, they reported that the new phone was producing different shortest paths than expected. The Maps team conducted a thorough review of their software, and found no possible errors – they have concluded it must be a hardware bug, and your manager agrees with them.</p> <p>The Maps team provided the following example graph and expected output:</p> <p><img src="figures/fuzz-figure1.png" width="40%" id="figure1" /></p> <p>The expected output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Distance of node 1=0x400
Path=1&lt;-0
Distance of node 2=0x500
Path=2&lt;-1&lt;-0
Distance of node 3=0x600
Path=3&lt;-2&lt;-1&lt;-0
</code></pre></div></div> <p>The output from the faulty CPU:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Distance of node 1=0x400
Path=1&lt;-0
Distance of node 2=0x500
Path=2&lt;-1&lt;-0
Distance of node 3=0x1000
Path=3&lt;-0
</code></pre></div></div> <p>The team is using <a href="https://gist.github.com/Suman2593/d357d24310b053838077dab5ca2b0c1d/">Dijkstra’s Algorithm</a> to find the shortest path between the nodes. They have tracked the bug to happening at this line in the code:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">mindistance</span><span class="o">+</span><span class="n">cost</span><span class="p">[</span><span class="n">nextnode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div></div> <p>In this part, we will analyze the CPU to figure out what is going wrong.</p> <h2 class="no_toc" id="getting-familiar-with-the-codebase"> <a href="#getting-familiar-with-the-codebase" class="anchor-heading" aria-labelledby="getting-familiar-with-the-codebase"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Familiar with the Codebase </h2> <p>Before we dig into the CPU internals, let’s get familiar with the lab infrastructure. In this part, you will be asked to navigate the codebase and answer several questions. No need to write any code.</p> <h3 class="no_toc" id="11-building-and-running-the-starter-code"> <a href="#11-building-and-running-the-starter-code" class="anchor-heading" aria-labelledby="11-building-and-running-the-starter-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.1 Building and Running the Starter Code </h3> <ol> <li>Checkout the lab codebase into your account on Unicorn.</li> <li><code class="language-plaintext highlighter-rouge">cd</code> into the <code class="language-plaintext highlighter-rouge">part1</code> directory and build it with <code class="language-plaintext highlighter-rouge">make</code></li> <li>Run the code with <code class="language-plaintext highlighter-rouge">./run.sh part1</code> from within the top level directory. You should see the incorrect output as shown above.</li> </ol> <p>Now, open the <code class="language-plaintext highlighter-rouge">part1</code> folder in your favorite code editor, and answer the following questions about the starter code in your report. These questions are intended to help guide you through the starter code – feel free to explore the code on your own too!</p> <blockquote class="discussion-title"> <p>1-1 Discussion Question</p> <ol> <li>Open <code class="language-plaintext highlighter-rouge">bringup.s</code> and read through the <code class="language-plaintext highlighter-rouge">start</code> method. What is the name of the C method that <code class="language-plaintext highlighter-rouge">start</code> jumps to when it finishes by running <code class="language-plaintext highlighter-rouge">mret</code>? Which CSR is used to hold that address?</li> <li><code class="language-plaintext highlighter-rouge">start</code> specifies an exception handler by writing to <code class="language-plaintext highlighter-rouge">CSR_MTVEC</code>. What is the name of the handler? What file is it implemented in?</li> <li><code class="language-plaintext highlighter-rouge">linker.ld</code> defines the memory map of the binary built by the build system. What section is the stack located in? How large is the stack?</li> <li>Open <code class="language-plaintext highlighter-rouge">asm_offsets.h</code>. This file is automatically generated when you compile the project. What is the offset of the <code class="language-plaintext highlighter-rouge">mepc</code> field of <code class="language-plaintext highlighter-rouge">saved_regs_t</code>? Where is <code class="language-plaintext highlighter-rouge">saved_regs_t</code> defined?</li> <li>Which RISC-V register is used as the return address in the calling convention? Which register is used as the stack pointer? (<em>Hint: Refer to Table 18.2 of the RISC-V Calling Convention</em>)</li> <li>What privilege mode does the starter code run the CPU in, after <code class="language-plaintext highlighter-rouge">mret</code> in <code class="language-plaintext highlighter-rouge">bringup.s</code>?</li> </ol> </blockquote> <h3 class="no_toc" id="12-debugging-the-cpu"> <a href="#12-debugging-the-cpu" class="anchor-heading" aria-labelledby="12-debugging-the-cpu"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.2 Debugging the CPU </h3> <p>Let’s inspect the code from the Maps team to learn why the CPU is not finding the correct shortest path. Open <code class="language-plaintext highlighter-rouge">dijkstra.c</code> and navigate to line 55.</p> <blockquote class="exercise-title"> <p>1-2 Exercise</p> <p>Let’s debug the CPU using the basic approach: using <code class="language-plaintext highlighter-rouge">printf</code>. Insert <code class="language-plaintext highlighter-rouge">printf</code> statements into <code class="language-plaintext highlighter-rouge">dijkstra.c</code> before line 55 to print the values of the operations performed by the <code class="language-plaintext highlighter-rouge">if</code> statement. Print all information relevant to the operation – that is, print the value of <code class="language-plaintext highlighter-rouge">mindistance</code>, <code class="language-plaintext highlighter-rouge">cost[nextnode][i]</code>, their sum as computed by the CPU, and <code class="language-plaintext highlighter-rouge">distance[i]</code>.</p> <p>Look at the CPU reported output of <code class="language-plaintext highlighter-rouge">mindistance+cost[nextnode][i]</code> and see whether you can capture the bug. We will not grade the coding for this part, since they are just a few <code class="language-plaintext highlighter-rouge">printf</code>.</p> </blockquote> <blockquote class="note-title"> <p>The <code class="language-plaintext highlighter-rouge">%d</code> option in <code class="language-plaintext highlighter-rouge">printf</code> is not supported in our code base. Please use <code class="language-plaintext highlighter-rouge">%x</code> instead.</p> </blockquote> <blockquote class="discussion-title"> <p>1-3 Discussion Question</p> <p>Based on the printf result, record what are the inputs (eg. values of <code class="language-plaintext highlighter-rouge">mindistance</code> and <code class="language-plaintext highlighter-rouge">cost[nextnode][i]</code>) that cause the addition instruction to return an incorrect sum? Does the operation fail for all inputs or just specific ones?</p> <p>(Note: You do not need to exhaustively test the input space, just report the ones you observe from running the starter program).</p> </blockquote> <h3 class="no_toc" id="submission-and-grading"> <a href="#submission-and-grading" class="anchor-heading" aria-labelledby="submission-and-grading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Write the answers to the questions in your report. No code for this part.</p> <h1 id="part-2-fuzzing-for-faulty-inputs-30"> <a href="#part-2-fuzzing-for-faulty-inputs-30" class="anchor-heading" aria-labelledby="part-2-fuzzing-for-faulty-inputs-30"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2: Fuzzing for Faulty Inputs (30%) </h1> <p>Impressed with your ability to understand incorrect CPU behavior, your boss has assigned you a new task – to write a program that can automatically test a given CPU to see if the addition bug is present, and if so, return what inputs cause the sum to fail.</p> <p>In the industry, we call such a program a <strong>regression test</strong> used to ensure that known bugs do not accidentally get reintroduced to the RTL before tapeout (when the CPU design is sent to the factory).</p> <p>We assume a bug is a set of inputs <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> that, when added together, produces an output that is not equal to <code class="language-plaintext highlighter-rouge">a+b</code>, just like we saw with the faulty results running Dijkstra’s algorithm above. We assume that the order of operands does not matter (that is, if <code class="language-plaintext highlighter-rouge">a+b</code> fails, then <code class="language-plaintext highlighter-rouge">b+a</code> fails too). We limit the search space of operands to <code class="language-plaintext highlighter-rouge">[0x100,0x1FF]</code> for both <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> (that is, only consider values of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> from 256 to 511 inclusive).</p> <p>Your task is to check the addition operator for all operands in the search space, and print out any operands that fail. Note that you cannot trust the CPU to perform the <code class="language-plaintext highlighter-rouge">add</code> instruction correctly (you can assume all other arithmetic instructions are bug-free). <em>How do you know if the CPU made a mistake? Or alternatively, how do you implement the specification for the <code class="language-plaintext highlighter-rouge">add</code> instruction in your code?</em> This is an <strong>open-ended</strong> problem with multiple possible solutions.</p> <blockquote class="discussion-title"> <p>2-1 Discussion Question</p> <p>What is your approach for finding the operands that can trigger the bug with the <code class="language-plaintext highlighter-rouge">add</code> instruction? Briefly describe it.</p> </blockquote> <blockquote class="note-title"> <p>Starting from this point, you are free to modify any C or assembly file you’d like!</p> <p>Additionally, you can add as many source files as you want – the build system will automatically build and link them for you!</p> </blockquote> <blockquote class="exercise-title"> <p>2-2 Exercise</p> <p>Navigate into the <code class="language-plaintext highlighter-rouge">part2</code> folder and create two new files – <code class="language-plaintext highlighter-rouge">fuzz.c</code> and <code class="language-plaintext highlighter-rouge">fuzz.h</code>.</p> <p>Create a method <code class="language-plaintext highlighter-rouge">void part2_fuzz_inputs()</code> and modify <code class="language-plaintext highlighter-rouge">shd.c</code> to call your new method from <code class="language-plaintext highlighter-rouge">shd_main</code>. You also need to <code class="language-plaintext highlighter-rouge">#include "fuzz.h"</code> and define a function signature for your new method.</p> <p>Your method should analyze all possible sums for operands between 256 and 511 (inclusive). If it finds any inputs that fail to produce the correct sum, it should print the input pair and what the erroneous sum was.</p> </blockquote> <blockquote class="note-title"> <p>When you want to call <code class="language-plaintext highlighter-rouge">printf()</code>, include our own printf from <code class="language-plaintext highlighter-rouge">utils.h</code>. The printf from <code class="language-plaintext highlighter-rouge">stdio.h</code>, which you were using in previous labs, is implemented to run on standard Linux, not on our psp, which has no operating system.</p> </blockquote> <p>For interacting with our grading scripts, you should use the following format specifier to print out failing operands: <code class="language-plaintext highlighter-rouge">printf("0x%X+0x%X=0x%X,0x%X\n",a,b,a+b,expected)</code> (where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are the buggy inputs, and <code class="language-plaintext highlighter-rouge">expected</code> is what they should have added up to). It is ok if the same inputs appear twice in swapped order (eg. if you print both <code class="language-plaintext highlighter-rouge">a,b,a+b,expected</code> and <code class="language-plaintext highlighter-rouge">b,a,b+a,expected</code>).</p> <p>Your output should look like:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
| MIT SHD Fuzz Lab |
|      Part 2      |
+------------------+
0x10+0x10=0x30,0x20
0x15+0x15=0x16,0x2A
...
</code></pre></div></div> <blockquote class="note-title"> <p>We will grade your lab on a CPU with random bugs!</p> <p>Do not assume the bugs present on the lab handout CPU will be the same that your code is graded against – your code should exhaustively search the input space to find and report all bugs!</p> <p>You should assume there can be zero or multiple addition bugs (inputs that cause the addition to fail) with randomly distributed operands.</p> </blockquote> <blockquote class="discussion-title"> <p>2-3 Discussion Question (optional)</p> <p>After completing part 2, please share with us: Did you encounter any bugs while implementing the fuzzer? How did you handle the possibility of <code class="language-plaintext highlighter-rouge">add</code> instructions being incorrect during control flow instructions (e.g., loop condition checks)?</p> </blockquote> <h3 class="no_toc" id="suggested-strategies--hints"> <a href="#suggested-strategies--hints" class="anchor-heading" aria-labelledby="suggested-strategies--hints"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Suggested Strategies / Hints </h3> <ul> <li>You could test your code by running it on the host Linux machine and use that as a “Gold” CPU model. (You probably need to change to include header files that are supported by the host linux and write another main function specifically for the host linux.) On the Linux host your code should report no bugs, and on Pretty Secure Processor it should report some bugs.</li> <li>Note that you <strong>cannot trust</strong> the CPU hardware to perform addition correctly. What happens if your loop logic requires a sum that is computed incorrectly?</li> </ul> <blockquote class="hint"> <p>You can use Python or a shell script to automate generation of your test cases. If you do, please commit these scripts to your repository as well, and include instructions for how to use them in your report.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-1"> <a href="#submission-and-grading-1" class="anchor-heading" aria-labelledby="submission-and-grading-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p><code class="language-plaintext highlighter-rouge">git add</code> all the new files you created for Part 2, including any Python or shell scripts you wrote to automate generation of your code. Running <code class="language-plaintext highlighter-rouge">./run.sh part2</code> should create a printout of the bugs your fuzzer found. Your code should run for no longer than 10 minutes.</p> <h1 id="part-3-fuzzing-for-a-hidden-cpu-backdoor-45"> <a href="#part-3-fuzzing-for-a-hidden-cpu-backdoor-45" class="anchor-heading" aria-labelledby="part-3-fuzzing-for-a-hidden-cpu-backdoor-45"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 3: Fuzzing for a Hidden CPU Backdoor (45%) </h1> <p>Bad news! This morning, a news report came out describing in the wild cases of PearPhone kernels being compromised by a new strain of malware. This malware is somehow capable of elevating the CPU privilege level from <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> to <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code>, bypassing all OS restrictions. While the CPU design team believes this is impossible, your boss has a suspicion – that someone inserted a malicious backdoor into the CPU itself!</p> <p>Whenever the CPU attempts to execute an undefined instruction, it is supposed to throw an exception with <code class="language-plaintext highlighter-rouge">mcause</code> set to <code class="language-plaintext highlighter-rouge">EXCEPTION_CAUSE_INVALID_INST</code> (see <code class="language-plaintext highlighter-rouge">defines.h:51</code>). Your boss believes the CPU backdoor is a single instruction encoded in an undefined region of the RISC-V ISA instruction encoding space that, when executed, does not throw an exception, but instead sneakily switches the privilege mode of the pipeline. An attacker who knows the encoding of this hidden instruction can use this to bypass the PearPhone OS security mechanisms.</p> <p>In this part, you will write a hidden instruction fuzzer to search automatically for backdoors in the CPU that elevate your privilege level to machine mode. We will start with searching for undocumented instructions, and then study their behavior.</p> <p>The following provides an overview of the intended approach for finding undocumented instructions:</p> <p><img src="figures/fuzz-figure2.png" width="60%" id="figure2" /></p> <p>Whenever the CPU encounters an instruction it cannot execute, it will throw an invalid instruction exception. For every instruction in the search space, we attempt to execute it, and watch for an exception. If any of them don’t generate an exception, we know that the CPU “understands” it as a valid opcode, and therefore it is a good candidate for being a CPU backdoor.</p> <h3 class="no_toc" id="31-writing-an-exception-handler"> <a href="#31-writing-an-exception-handler" class="anchor-heading" aria-labelledby="31-writing-an-exception-handler"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.1 Writing an Exception Handler </h3> <p>Before we can search for undefined instructions, we need to be able to handle exceptions. For actually undefined instructions, trying to run them will cause the exception handler to run. For any backdoors, the exception handler will not be called (as the backdoor is decoded as a valid instruction). <!-- Any instructions we expect to be undefined that do not generate exceptions are suspicious. --></p> <p>Here is a description of a possible exception handler for you to implement. It saves all registers (<code class="language-plaintext highlighter-rouge">x1</code>-<code class="language-plaintext highlighter-rouge">x31</code> and <code class="language-plaintext highlighter-rouge">mepc</code>, which holds the <code class="language-plaintext highlighter-rouge">pc</code> value of the faulting instruction), handles the exception logic (possibly changing the values of some of the saved registers), and then loads the new CPU state before finally executing <code class="language-plaintext highlighter-rouge">mret</code>.</p> <p>Recall that you have found the file that should implement the exception handler in part1. Our implementation in the starter code only includes the first half of the exception handling that 1) creates space on the stack for a new <code class="language-plaintext highlighter-rouge">saved_regs_t</code>, 2) stores the registers into it, and 3) passes the address of this struct to <code class="language-plaintext highlighter-rouge">exception.c</code>. You can use our test method named <code class="language-plaintext highlighter-rouge">exception_test()</code> (defined in <code class="language-plaintext highlighter-rouge">exception_test.s</code>) to test your exception handler. The test method generates an illegal instruction exception and checks whether your exception handler is saving and restoring the CPU state correctly. Start by modifying <code class="language-plaintext highlighter-rouge">shd_main</code> to call <code class="language-plaintext highlighter-rouge">exception_test()</code>. You should see something like the following, telling you the exception handler in the starter code is incomplete:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
| MIT SHD Fuzz Lab |
|      Part 3      |
+------------------+
Triggering exception...
=============================
Exception!
pc:  0x000005F0
x1:  0x11111111    x2:  0x00002FD0    x3:  0x33333333    x4:  0x44444444
x5:  0x55555555    x6:  0x66666666    x7:  0x77777777    x8:  0x88888888
x9:  0x99999999    x10: 0x10101010    x11: 0x11111111    x12: 0x12121212
x13: 0x13131313    x14: 0x14141414    x15: 0x15151515    x16: 0x16161616
x17: 0x17171717    x18: 0x18181818    x19: 0x19191919    x20: 0x20202020
x21: 0x21212121    x22: 0x22222222    x23: 0x23232323    x24: 0x24242424
x25: 0x25252525    x26: 0x26262626    x27: 0x27272727    x28: 0x28282828
x29: 0x29292929    x30: 0x30303030    x31: 0x31313131
TODO: You need to write the exception handler return code!
</code></pre></div></div> <blockquote class="exercise-title"> <p>3-1 Exercise</p> <p>Read through the starter code in <code class="language-plaintext highlighter-rouge">exception_entry.s</code>. Your task is to implement the second half of the exception handler assembly in <code class="language-plaintext highlighter-rouge">exception_entry.s</code>, and fill in <code class="language-plaintext highlighter-rouge">exception.c</code> with any logic your code needs.</p> <p>First, remove the code that causes the handler to print <code class="language-plaintext highlighter-rouge">TODO: You need to write the exception handler return code!</code> and halt. Next, you should fill in the <code class="language-plaintext highlighter-rouge">TODO</code>’s in <code class="language-plaintext highlighter-rouge">exception_entry.s</code> to restore the saved state (the opposite of what the starter code does).</p> <p>Finally, fill in the TODO in <code class="language-plaintext highlighter-rouge">exception_handler</code> in <code class="language-plaintext highlighter-rouge">exception.c</code> (the C method called by the handler entry assembly) to properly handle the fault. If the exception cause was an illegal instruction, at minimum this means incrementing the saved <code class="language-plaintext highlighter-rouge">mepc</code> by one RISC-V instruction length to resume execution at the next assembly instruction after the undefined one. You will add more logic here in the later parts.</p> <p>If implemented correctly, <code class="language-plaintext highlighter-rouge">exception_test()</code> should print <code class="language-plaintext highlighter-rouge">Passed exception test!</code>.</p> </blockquote> <blockquote class="discussion-title"> <p>3-2 Discussion Question</p> <p>Why does the exception handler restore <code class="language-plaintext highlighter-rouge">x2</code> <strong>after</strong> all the other registers?</p> </blockquote> <blockquote class="hint"> <p>Here is how RISC-V exception returns are handled by the <a href="https://github.com/torvalds/linux/blob/f0bddf50586da81360627a772be0e355b62f071e/arch/riscv/kernel/entry.S#L137">Linux kernel</a>.</p> </blockquote> <!-- {: .note-title} > To attach to the CPU with GDB, use `./run.sh debug`. > In another window, run `./gdb.sh`, again from within the `part4` directory. --> <p>Note that the starter code is just a suggested approach – feel free to remove it and rewrite it however you want!</p> <p>This part is considered complete if <code class="language-plaintext highlighter-rouge">exception_test</code> reports your exception handler passed.</p> <blockquote class="note-title"> <p>In later parts, you are allowed to modify your exception handler in any way you want, including in ways that make <code class="language-plaintext highlighter-rouge">exception_test</code> fail.</p> <p><code class="language-plaintext highlighter-rouge">exception_test</code> will report a failure if <strong>any</strong> register <code class="language-plaintext highlighter-rouge">x1-x31</code> is changed by the exception handler. For this lab, you may actually want to modify registers in the <code class="language-plaintext highlighter-rouge">saved_regs_t</code>, which is acceptable!</p> <p>You will not lose points if <code class="language-plaintext highlighter-rouge">exception_test</code> says your code fails. It is just a guideline to help you implement Part 3.</p> <p>We recommend starting with an exception handler that passes <code class="language-plaintext highlighter-rouge">exception_test</code> to ensure your assembly is correct, and adjusting it later in the lab as you want. For this reason, we also recommend <code class="language-plaintext highlighter-rouge">git commit</code>‘ing your code at this current state, in case you later break your exception handler and want to restore it to the previously working version.</p> </blockquote> <h3 class="no_toc" id="32-searching-for-undocumented-hidden-instructions"> <a href="#32-searching-for-undocumented-hidden-instructions" class="anchor-heading" aria-labelledby="32-searching-for-undocumented-hidden-instructions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.2 Searching for Undocumented Hidden Instructions </h3> <p>Now that we can catch illegal instruction exceptions, it’s time to scan for backdoors. Your boss wants you to only consider the <code class="language-plaintext highlighter-rouge">custom-0</code> subspace of the instruction encoding space. <code class="language-plaintext highlighter-rouge">custom-0</code> has an opcode of <code class="language-plaintext highlighter-rouge">0001011</code>, or <code class="language-plaintext highlighter-rouge">0x0B</code> (See <strong>Table 24.1</strong> in Volume I of the RISC-V ISA Specification on page 129). The CPU does not officially support any <code class="language-plaintext highlighter-rouge">custom-0</code> instructions, so if you find one that doesn’t throw an illegal instruction exception, it is a hidden instruction!</p> <p>Your boss said that while the opcode is probably <code class="language-plaintext highlighter-rouge">custom-0</code>, the decode stage of the pipeline is likely stealthily rejecting all instructions with this opcode whose upper immediate bits do not match some secret. You should treat this backdoor instruction as a U type RISC-V instruction, where the upper immediate bits (bits 31 to 12) are a secret, and the opcode is <code class="language-plaintext highlighter-rouge">custom-0</code>.</p> <p>Recall the RISC-V 32I instruction encodings (Volume I Figure 2.2 on Page 16):</p> <p><img src="figures/fuzz-part42.png" width="70%" /></p> <p>In this part, you will loop over all <code class="language-plaintext highlighter-rouge">custom-0</code> instructions with different possible upper immediate bits. That is, you should generate all instructions where the <code class="language-plaintext highlighter-rouge">opcode</code> field (bits <code class="language-plaintext highlighter-rouge">6:0</code>) is set to <code class="language-plaintext highlighter-rouge">custom-0</code>, and the upper bits (<code class="language-plaintext highlighter-rouge">31:12</code>) are set to a guessed secret value. You will execute each instruction, and then check if a CPU illegal instruction exception occurred. If it did not, you should print out the full encoding that caused no exception.</p> <p>You can calculate a single instruction encoding with the following:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">OP_CUSTOM0</span> <span class="o">=</span> <span class="mh">0x0B</span> <span class="c1"># See Table 24.1 in Volume I of the ISA Spec.
</span><span class="k">def</span> <span class="nf">encode_instruction</span><span class="p">(</span><span class="n">secret</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">OP_CUSTOM0</span> <span class="o">|</span> <span class="p">(</span><span class="n">secret</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span>
</code></pre></div></div> <p>For this lab, only consider the cases where the upper immediate bits (secret value) are between <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">65535</code> inclusive.</p> <h3 class="no_toc" id="high-level-guideline"> <a href="#high-level-guideline" class="anchor-heading" aria-labelledby="high-level-guideline"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> High-level Guideline </h3> <p>You will need to test all possible instruction encodings in this region. If an instruction is invalid, it will trigger the execution of the invalid opcode exception handler. After executing the handler, we will return to the test code. If it is a hidden instruction, the code will just run through without executing the handler. Your key task to identify a hidden instruction will be to distinguish between the case when an exception has happened and the case when an exception has not happened. At a high level, you will need to figure out a way for the invalid opcode exception handler to communicate information to the test code. This can be done via setting flags in memory or in specific registers or many other ways. You can pick the one you like to implement. It is ok if your design decision causes your exception handler to fail <code class="language-plaintext highlighter-rouge">exception_test</code> as long as you are able to discover the backdoor opcode.</p> <p>Note that a key challenge in this part is that you will need to test many instructions. You will not want to write the code manually. Possible solutions include generating the test code automatically with Python, or making use of self-modifying code. If you write automation scripts, make sure to commit them to your repo, and include documentation of how they work in your report. (Only submitting a massive auto-generated assembly file is unacceptable).</p> <p>For now, your test code runs with <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code> privileges (see <code class="language-plaintext highlighter-rouge">bringup.s</code>).</p> <blockquote class="discussion-title"> <p>3-3 Discussion Question</p> <p>Describe your design decisions for the exception handler. What does it do while trying to find the undocumented instruction? How does your exception handler communicate with the test code?</p> </blockquote> <blockquote class="exercise-title"> <p>3-4 Exercise</p> <p>Write a method that tries all <code class="language-plaintext highlighter-rouge">65536</code> possible <code class="language-plaintext highlighter-rouge">custom-0</code> instructions, with the upper bits (bits 31 to 12) set to a value between <code class="language-plaintext highlighter-rouge">[0,65535]</code> inclusive. If it finds an instruction that does not throw an illegal instruction exception, it prints the opcode to serial with <code class="language-plaintext highlighter-rouge">printf</code>. If no instruction is found, it prints that it could not find any hidden instructions.</p> </blockquote> <blockquote class="discussion-title"> <p>3-5 Discussion Question</p> <p>Include the hidden backdoor instruction found by your code/script in the report.</p> </blockquote> <blockquote class="note-title"> <p>This is an open ended programming task!</p> <p>You are allowed to modify any and all parts of the starter code. You can implement this method in assembly or in C. You can create as many extra files as you need to. You will likely need to modify the exception handler as well to support your code.</p> </blockquote> <h3 class="no_toc" id="a-few-assembly-tips"> <a href="#a-few-assembly-tips" class="anchor-heading" aria-labelledby="a-few-assembly-tips"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> A Few Assembly Tips </h3> <p>Here are a few assembly tips that may come in handy. Note that you do not necessarily need to use any or all of them.</p> <blockquote class="note-title-title"> <p>Shared variables between C and ASM</p> <p>Recall that assembly symbols can be exported to C with the <code class="language-plaintext highlighter-rouge">.global</code> keyword. So, to create a variable that is shared between C and assembly, I can write the following in assembly:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.global shared_var
shared_var: .word 0x1234
</code></pre></div> </div> <p>And then in C refer to it with the <code class="language-plaintext highlighter-rouge">extern</code> keyword:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern uint32_t shared_var;
</code></pre></div> </div> </blockquote> <blockquote class="note-title-title"> <p>Emitting Arbitrary Instructions</p> <p>You can emit an arbitrary encoding for an instruction with the <code class="language-plaintext highlighter-rouge">.word</code> keyword.</p> <p>For example, here is how to add the instruction encoded by <code class="language-plaintext highlighter-rouge">0x41414141</code> to the program:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>some_asm_method:
   add sp, sp, -4
   .word 0x41414141
   add sp, sp, 4
</code></pre></div> </div> <p>See <code class="language-plaintext highlighter-rouge">exception_test.s:111</code> for an example!</p> </blockquote> <blockquote class="note-title-title"> <p>Inline Assembly</p> <p>You may find the <a href="https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html">inline assembly</a> <code class="language-plaintext highlighter-rouge">gcc</code> features to be useful.</p> </blockquote> <h3 class="no_toc" id="hints-warnings"> <a href="#hints-warnings" class="anchor-heading" aria-labelledby="hints-warnings"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hints/ Warnings </h3> <ul> <li>Recall that the CPU does have bugs with the <code class="language-plaintext highlighter-rouge">add</code> instruction, so be careful if your opcode enumeration code requires addition!</li> <li>If your approach makes use of self modifying code, insert 5 <code class="language-plaintext highlighter-rouge">nop</code> instructions after your write instruction to flush the CPU pipeline. (If you try to write to an instruction and then immediately run it, a stale opcode may be in the pipeline.)</li> <li>Don’t forget to commit any extra files you add to your <code class="language-plaintext highlighter-rouge">git</code> repo!</li> <li>You can automate parts of your solution by writing Python code to produce assembly in bulk (eg. <code class="language-plaintext highlighter-rouge">print(f"la a0, {test_case}")</code> will emit the assembly code to load <code class="language-plaintext highlighter-rouge">a0</code> with the Python variable <code class="language-plaintext highlighter-rouge">test_case</code>). If you write Python code, commit the Python code to your repo.</li> <li>If your assembly code is too long, you might see <code class="language-plaintext highlighter-rouge">relocation truncated to fit: R_RISCV_JAL</code> error during the compilation. Here is what happens: JAL instruction can only jump to a range of [-1MB, 1MB]. If some function in your code is too long, this range might not be enough. To solve this, you could change your JAL instructions to JALR.</li> <li>Your exception handler needs to communicate with your test code in some way to report when exceptions occur. How this works is up to you.</li> </ul> <p>This part is considered complete if your code finds and prints the opcode of the hidden backdoor instruction.</p> <h3 class="no_toc" id="33-elevating-privileges-to-kernel-mode"> <a href="#33-elevating-privileges-to-kernel-mode" class="anchor-heading" aria-labelledby="33-elevating-privileges-to-kernel-mode"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.3 Elevating Privileges to Kernel Mode </h3> <p>Congrats on finding a hidden instruction! Your boss, amazed at your skills, wants to see if you can figure out how to activate the backdoor. You may have noticed that even after running the backdoor, you still cannot access privileged CSRs from <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> (try it!). Attempting to load a privileged CSR when the core is booted in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> should throw a <code class="language-plaintext highlighter-rouge">EXCEPTION_CAUSE_ILLEGAL_ACCESS (mcause=0x00000001)</code> exception, even if the backdoor instruction is run first.</p> <p>So, why doesn’t the backdoor work?</p> <p>It seems that the authors of the backdoor were even sneakier than we thought, and added another condition that must be satisfied before the backdoor instruction elevates your privileges.</p> <p>Your boss took the CPU to a <strong>focused-ion beam</strong> (FIB), and found a wire connecting the decode stage to register <code class="language-plaintext highlighter-rouge">x10</code> that wasn’t in the original design. Your boss suspects that <code class="language-plaintext highlighter-rouge">x10</code> must be loaded with a secret value before the backdoor is called.</p> <blockquote class="note-title"> <p>So far, your code has been running in <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code>. Before continuing, update <code class="language-plaintext highlighter-rouge">bringup.s</code> to start your code with <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> instead. This way, we can check to see if we gained any extra privileges by running the backdoor instruction.</p> <p>Additionally, for Part 3.3, you can hard-code the opcode you discovered in Part 3.2.</p> </blockquote> <blockquote class="discussion-title"> <p>3-6 Discussion Question</p> <p>Describe your approach for finding the correct <code class="language-plaintext highlighter-rouge">x10</code> value. Does the exception handler behave differently when searching for the correct <code class="language-plaintext highlighter-rouge">x10</code> value of that instruction compared to searching for hidden instructions?</p> </blockquote> <blockquote class="exercise-title"> <p>3-7 Exercise</p> <p>Write some code to try and load a privileged CSR (pick any CSR you want!) and run it without running the backdoor instruction. You should see that the load succeeds if <code class="language-plaintext highlighter-rouge">bringup.s</code> starts your code in <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code> mode, and throws an exception if it starts in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code>.</p> <p>Now, while running in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code>, add a call to the backdoor instruction before the CSR read. You should still see an exception being thrown, even if you ran the backdoor instruction. This is because the backdoor is not called with the correct value for <code class="language-plaintext highlighter-rouge">x10</code>, and so it does not change the privilege level.</p> <p>Modify your code to set <code class="language-plaintext highlighter-rouge">x10</code> to values between <code class="language-plaintext highlighter-rouge">[0,65535]</code> inclusive before calling the backdoor. For each value in <code class="language-plaintext highlighter-rouge">[0,65535]</code>, set <code class="language-plaintext highlighter-rouge">x10</code> to the value, run the backdoor instruction discovered in Part 3.2, and then try to load a CSR. If the CSR load succeeds, print the value of <code class="language-plaintext highlighter-rouge">x10</code> out. If it fails, try another value of <code class="language-plaintext highlighter-rouge">x10</code>. You may need to modify your exception handler code to detect when CSR loads cause faults.</p> <p>When complete, your code should be able to start in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code>, call the backdoor with different <code class="language-plaintext highlighter-rouge">x10</code> values until the CPU privilege level changes, and then read the contents of a privileged CSR.</p> </blockquote> <blockquote class="discussion-title"> <p>3-8 Discussion Question</p> <p>Include the correct <code class="language-plaintext highlighter-rouge">x10</code> value found by your code/script in the report.</p> </blockquote> <blockquote class="hint"> <p>When a CSR load fails, the CPU throws a different kind of exception- <code class="language-plaintext highlighter-rouge">EXCEPTION_CAUSE_ILLEGAL_ACCESS (0x00000001)</code> (see <code class="language-plaintext highlighter-rouge">defines.h:48</code>). You can use this to distinguish CSR load failures from illegal instruction exceptions.</p> </blockquote> <h3 class="no_toc" id="34-putting-it-all-together"> <a href="#34-putting-it-all-together" class="anchor-heading" aria-labelledby="34-putting-it-all-together"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.4 Putting it All Together </h3> <p>Now we will combine your code to discover hidden instructions with your code to fuzz those instructions. <!-- Create a new C or assembly file for Part 3.4. This new file should have one method that can be called from `shd.c`. --> Your combined code should, in one go, search the undocumented instructions to find the backdoor instruction, fuzz the backdoor instruction for the correct <code class="language-plaintext highlighter-rouge">x10</code> value, and then print both the correct opcode and <code class="language-plaintext highlighter-rouge">x10</code> value to standard out.</p> <blockquote class="exercise-title"> <p>3-9 Exercise: Putting it All Together</p> <p>Combine your code from Parts 3.2 and 3.3, printing both the discovered opcode and <code class="language-plaintext highlighter-rouge">x10</code> value to standard out.</p> </blockquote> <blockquote class="discussion-title"> <p>3-10 Discussion Question (optional)</p> <p>After completing part 3, please share with us:</p> <p>Did you encounter any challenges while building the code? How did you overcome the challenges of the <code class="language-plaintext highlighter-rouge">add</code> instruction occasionally producing an incorrect result? Did you try anything that failed?</p> </blockquote> <blockquote class="note-title"> <p>When grading Part 3 we will run your code on a different CPU with a different backdoor opcode and <code class="language-plaintext highlighter-rouge">x10</code> encoding, so do not assume anything about the value of these constants besides they are within the bounds specified in this document.</p> <p>You can assume that at most one backdoor instruction exists with exactly one correct <code class="language-plaintext highlighter-rouge">x10</code> value corresponding to it.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-2"> <a href="#submission-and-grading-2" class="anchor-heading" aria-labelledby="submission-and-grading-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p><code class="language-plaintext highlighter-rouge">git add</code> all the new files you created for Part 3, including any Python or shell scripts you wrote to automate generation of your code. When we build and run the contents of your <code class="language-plaintext highlighter-rouge">part3</code> directory, your code for Part 3.4 should immediately begin running, and report the correct opcode and <code class="language-plaintext highlighter-rouge">x10</code> value discovered on the hardware (which again, will have different values when we grade than they are on your assigned CPU).</p> <p>Your part 3 output should follow the following format (<code class="language-plaintext highlighter-rouge">printf("backdoor=0x%X\n",backdoor)</code> and <code class="language-plaintext highlighter-rouge">printf("x10=0x%X\n",x10_val)</code>):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
| MIT SHD Fuzz Lab |
|      Part 3      |
+------------------+
backdoor=0x????00B
x10=0x????
</code></pre></div></div> <h1 id="part-4-using-the-backdoor-to-exploit-a-remote-system-15"> <a href="#part-4-using-the-backdoor-to-exploit-a-remote-system-15" class="anchor-heading" aria-labelledby="part-4-using-the-backdoor-to-exploit-a-remote-system-15"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 4: Using the Backdoor to Exploit a Remote System (15%) </h1> <p>For this final part, you will combine all of the bugs you have discovered so far to exploit a remote secure server. There is a Pretty Secure Processor running on the network hosting a C application running in unprivileged mode (<code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code>). This application is correctly written and suffers from no buffer overflow bugs during normal execution. However, the CPU suffers from the <code class="language-plaintext highlighter-rouge">add</code> bug as you have seen in the earlier parts of this lab. It also has the backdoor present which can be used to elevate your privileges to <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code> once code execution has been obtained.</p> <p>The source code for this secure server is found in the <code class="language-plaintext highlighter-rouge">part4</code> directory. We will begin by testing our exploit on a local CPU where we can run with <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code> privileges and use <code class="language-plaintext highlighter-rouge">gdb</code> for testing. First, we will manipulate the CPU to cause a buffer overflow by feeding it inputs that cause the <code class="language-plaintext highlighter-rouge">add</code> instruction to malfunction, bypassing the bounds check. Next, we will write some RISC-V assembly to dump a hidden secret from the CPU by reading from some special CSRs – this assembly is the code we want to run on the remote processor. Finally, we will implement a return to shellcode attack, storing the assembly we wrote in the input buffer and tricking the CPU into jumping to it by overwriting the saved return address.</p> <p>This will allow us to send code to the remote CPU to run and cause it to be executed, granting us full control of the remote CPU.</p> <p>This part will introduce you to several commonly used CTF tools. You have also seen these tools in recitation. We will guide you through the process of using these tools to implement a software-hardware exploit on a remote server.</p> <h3 class="no_toc" id="getting-started-1"> <a href="#getting-started-1" class="anchor-heading" aria-labelledby="getting-started-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h3> <p>First, <code class="language-plaintext highlighter-rouge">cd</code> into <code class="language-plaintext highlighter-rouge">part4</code>, build it with <code class="language-plaintext highlighter-rouge">make</code>, and run it. You should see something like the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
| MIT SHD Fuzz Lab |
|      Part 4      |
+------------------+
inputbuf is at 0x2CD4
How long is your first name: 7
How long is your last name: 5
Ok, tell me your first name: Joseph
And your last name: Ravi
Your username is JosephRavi
</code></pre></div></div> <p>Play around with the inputs and get a feel for how the application works. Note that the length inputs require you to add 1 byte for the newline character. That is, if your name is <code class="language-plaintext highlighter-rouge">Joseph</code> (6 chars), you would need to add a 7th character for the newline.</p> <p>See if you can overflow the buffer by typing in a large name. You should be unable to cause a crash (if you did, let us know on Piazza!)</p> <h3 class="no_toc" id="41-redirecting-control-flow"> <a href="#41-redirecting-control-flow" class="anchor-heading" aria-labelledby="41-redirecting-control-flow"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.1 Redirecting Control Flow </h3> <p>Our primary objective of this part is to modify <code class="language-plaintext highlighter-rouge">pc</code> to point to an arbitrary address. We will accomplish this using a <strong>buffer overflow</strong>.</p> <p>Open <code class="language-plaintext highlighter-rouge">shd.c</code> and take a look at the code. You should see the following bounds check:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">fname_len</span> <span class="o">+</span> <span class="n">lname_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inputbuf</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Error: Your name is too large!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This bounds check prevents the buffer from being overflown by normal inputs.</p> <p>As we control both <code class="language-plaintext highlighter-rouge">fname_len</code> and <code class="language-plaintext highlighter-rouge">lname_len</code>, we can skip this bounds check by feeding in inputs that should fail the check, but instead pass (their sum is less than <code class="language-plaintext highlighter-rouge">sizeof(inputbuf)</code>) because of a bug in the <code class="language-plaintext highlighter-rouge">add</code> instruction. Revisit the bugs you found in Part 2 and pick a set of inputs that satisfy this condition and try them here. Can you bypass the name length check? (Try it in the terminal!)</p> <p>Once you have found input lengths that bypass the bounds check, see if you can get the CPU to crash by feeding in a really long username. You should be able to achieve something like the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------------------+
| MIT SHD Fuzz Lab |
|      Part 4      |
+------------------+
inputbuf is at 0x2CD4
How long is your first name: {REDACTED}
How long is your last name: {REDACTED}
Ok, tell me your first name: AAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
...
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
And your last name: Your username is AAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
...
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
=============================
Exception!
pc:  0x41414141
x1:  0x41414141    x2:  0x00002FF0    x3:  0x00000000    x4:  0x00000000
x5:  0x00000000    x6:  0x00000000    x7:  0x00000000    x8:  0x41414141
x9:  0x00000000    x10: 0x0000000A    x11: 0x00002CD4    x12: 0x00000000
x13: 0x00000000    x14: 0x0000000A    x15: 0x00000000    x16: 0x00000000
x17: 0x00000000    x18: 0x00000000    x19: 0x00000000    x20: 0x00000000
x21: 0x00000000    x22: 0x00000000    x23: 0x00000000    x24: 0x00000000
x25: 0x00000000    x26: 0x00000000    x27: 0x00000000    x28: 0x00000000
x29: 0x00000000    x30: 0x00000000    x31: 0x00000000
TODO: You need to write the exception handler return code!
</code></pre></div></div> <p>Notice how we crashed with <code class="language-plaintext highlighter-rouge">pc=0x41414141</code>. <code class="language-plaintext highlighter-rouge">0x41</code> is the ASCII encoding for the character <code class="language-plaintext highlighter-rouge">A</code>. This is great news! It means that our input somehow made its way into the <code class="language-plaintext highlighter-rouge">pc</code> register by overwriting the saved <code class="language-plaintext highlighter-rouge">ra</code> on the stack somewhere.</p> <p><code class="language-plaintext highlighter-rouge">shd_main</code> stores the return address on the stack, and restores it before exiting. Since we bypassed the buffer size check, our string was so large that it overwrote this value on the stack, meaning that when <code class="language-plaintext highlighter-rouge">shd_main</code> tried to return, it instead treated our input as an address and tried to jump to it.</p> <blockquote class="note-title"> <p>You will see <code class="language-plaintext highlighter-rouge">0x41414141</code> in a lot of security blog posts as a “proof-of-concept” that a bug is exploitable.</p> </blockquote> <p>Now open <code class="language-plaintext highlighter-rouge">solve_part4.py</code>. This is a Python script that uses the <a href="https://docs.pwntools.com/en/stable/"><code class="language-plaintext highlighter-rouge">pwntools</code></a> library to automate interacting with the processor. This script will allow us to easily send non-printable characters (like assembly bytes) into the CPU. We have filled in a starter skeleton for you to use to build your exploits. Feel free to write your exploit however you want, the starter skeleton is simply a guide.</p> <p>We will use this script to automate overflowing the buffer and precisely redirecting code flow to our controlled data on the stack.</p> <p>Note that while our earlier proof-of-concept (filling the buffer with <code class="language-plaintext highlighter-rouge">AAAAAAA...</code>) proved that we can gain control of <code class="language-plaintext highlighter-rouge">pc</code>, it did not tell us <strong>which part</strong> of our input eventually made its way into <code class="language-plaintext highlighter-rouge">pc</code>. That’s because every byte of our input is identical! (That is, we don’t know if it was the first <code class="language-plaintext highlighter-rouge">A</code>, one of the <code class="language-plaintext highlighter-rouge">A</code>’s in the middle, or the last <code class="language-plaintext highlighter-rouge">A</code> that made it into <code class="language-plaintext highlighter-rouge">pc</code> since they are all the same).</p> <p><code class="language-plaintext highlighter-rouge">pwntools</code> provides the method <a href="https://docs.pwntools.com/en/stable/util/cyclic.html"><code class="language-plaintext highlighter-rouge">cyclic</code></a> that allows us to fix this issue in a really efficient way. <code class="language-plaintext highlighter-rouge">cyclic</code> returns what’s called a <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence">de Bruijn sequence</a>. The output of this is a series of unique 4 byte chunks that do not repeat (for a very long time, anyways). Give it a try:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; cyclic(100)
b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
</code></pre></div></div> <p>Generate a long username with <code class="language-plaintext highlighter-rouge">cyclic</code> and use that as your username. You should see a new crash <code class="language-plaintext highlighter-rouge">pc</code> value. This <code class="language-plaintext highlighter-rouge">pc</code> value will be the ASCII encoding of some unique part of the de Bruijn sequence. Since each 4 byte chunk is different, we now know exactly where in the input sequence <code class="language-plaintext highlighter-rouge">pc</code> is being read from.</p> <p>For example <code class="language-plaintext highlighter-rouge">pc</code> could be <code class="language-plaintext highlighter-rouge">0x6161616F</code>. Using this feedback, <code class="language-plaintext highlighter-rouge">pwntools</code> quickly allows you to look up the offset in the input string that controls <code class="language-plaintext highlighter-rouge">pc</code> with <code class="language-plaintext highlighter-rouge">cyclic_find</code>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; cyclic_find(0x6161616F)
56
</code></pre></div></div> <p>In this example, the offset 56 bytes into my overflow was what controlled <code class="language-plaintext highlighter-rouge">pc</code>.</p> <blockquote class="exercise-title"> <p>4-1 Exercise</p> <p>Open <code class="language-plaintext highlighter-rouge">solve_part4.py</code>.</p> <p>Fill in <code class="language-plaintext highlighter-rouge">FIRSTNAME_LEN</code> and <code class="language-plaintext highlighter-rouge">LASTNAME_LEN</code> with the inputs you found above. Fill in the argument to <code class="language-plaintext highlighter-rouge">cyclic_find</code> with the <code class="language-plaintext highlighter-rouge">pc</code> value you found using <code class="language-plaintext highlighter-rouge">cyclic</code>. This will fill in <code class="language-plaintext highlighter-rouge">buf</code> with enough <code class="language-plaintext highlighter-rouge">A</code>’s to stop right before what gets filled into <code class="language-plaintext highlighter-rouge">pc</code>.</p> <p>Now, the next 4 bytes input into <code class="language-plaintext highlighter-rouge">buf</code> will be put into <code class="language-plaintext highlighter-rouge">pc</code> when <code class="language-plaintext highlighter-rouge">shd_main</code> returns. These bytes must be packed as a 32 bit integer (little endian), which the <a href="https://docs.pwntools.com/en/stable/util/packing.html">p32</a> method will handle for you. Fill in some hex number into the <code class="language-plaintext highlighter-rouge">p32</code> call, send the <code class="language-plaintext highlighter-rouge">buf</code> to the processor as the first and last names, and run the script – you should see a crash with <code class="language-plaintext highlighter-rouge">pc</code> set to that hex number.</p> <p>Once you can reliably use <code class="language-plaintext highlighter-rouge">solve_part4.py</code> to change <code class="language-plaintext highlighter-rouge">pc</code> to an arbitrary address, you are done with Part 4.1!</p> </blockquote> <h3 class="no_toc" id="42-dumping-the-flag"> <a href="#42-dumping-the-flag" class="anchor-heading" aria-labelledby="42-dumping-the-flag"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2 Dumping the Flag </h3> <p>Now, we will write some assembly to read the flag from a sequence of CSRs. CSRs <code class="language-plaintext highlighter-rouge">0xFC0</code> to <code class="language-plaintext highlighter-rouge">0xFF0</code> contain a hidden secret flag that requires <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code> to read. The first ASCII char of the flag is stored in CSR <code class="language-plaintext highlighter-rouge">0xFC0</code>, the next in <code class="language-plaintext highlighter-rouge">0xFC1</code>, and so on.</p> <blockquote class="exercise-title"> <p>4-2 Exercise</p> <p>Create a new C or assembly file with a method that reads CSRs starting at <code class="language-plaintext highlighter-rouge">0xFC0</code> and ending at <code class="language-plaintext highlighter-rouge">0xFF0</code>. If you are using assembly, don’t forget to mark your method as global with <code class="language-plaintext highlighter-rouge">.global</code>. For each CSR, write the value read to CSR <code class="language-plaintext highlighter-rouge">0x202</code> (the softserial output port) to display it in the terminal.</p> <p>To test your code, modify <code class="language-plaintext highlighter-rouge">bringup.s</code> to boot the CPU with <code class="language-plaintext highlighter-rouge">PSP_PRIV_MACHINE</code>, modify <code class="language-plaintext highlighter-rouge">shd.c</code> to call your method (add a call to it somewhere in <code class="language-plaintext highlighter-rouge">shd_main</code>), and run the processor. You should see an example flag printed out to the terminal.</p> <p>Once that is working, modify back <code class="language-plaintext highlighter-rouge">bringup.s</code> to boot the CPU with <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code>. Your flag dumper should no longer work. Add a call to the backdoor instruction you discovered in Part 3 to your flag dump routine, and try it again – the flag dumper should once again work.</p> </blockquote> <blockquote class="discussion-title"> <p>4-3 Discussion Question</p> <p>This part is complete once your flag dump routine can dump CSRs <code class="language-plaintext highlighter-rouge">0xFC0</code> to <code class="language-plaintext highlighter-rouge">0xFF0</code> to the console, even when <code class="language-plaintext highlighter-rouge">bringup.s</code> boots the CPU in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> mode. You should see an example flag of the form <code class="language-plaintext highlighter-rouge">MIT{...}</code> printed. Include this flag in your report.</p> </blockquote> <blockquote class="hint"> <p>We recommend using assembly for this part. We also recommend automatically generating your assembly code with a Python script. Create a Python script called <code class="language-plaintext highlighter-rouge">gen_dump_flag.py</code> and fill it with <code class="language-plaintext highlighter-rouge">print</code> commands to output the assembly instructions you need to dump the flag.</p> <p>Make sure to output a symbol and mark it as global so you can find it from C. (eg. <code class="language-plaintext highlighter-rouge">.global flag_dump</code> and <code class="language-plaintext highlighter-rouge">flag_dump:</code> before your instructions).</p> </blockquote> <blockquote class="note-title"> <p>Refer to <code class="language-plaintext highlighter-rouge">serial_csr.s</code> for a refresher on how to read/ write CSRs! (Specifically, the serial port).</p> <p>You may also find referring to the <a href="./psp.html#what-are-csrs">psp documentation</a> page useful.</p> </blockquote> <h3 class="no_toc" id="43-writing-the-exploit"> <a href="#43-writing-the-exploit" class="anchor-heading" aria-labelledby="43-writing-the-exploit"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.3 Writing the Exploit </h3> <p>We will now combine the primitives from parts 4.1 and 4.2 to exploit the remote CPU. To recap, in Part 4.1 we discovered how to modify control flow (e.g., change the <code class="language-plaintext highlighter-rouge">pc</code> register) by causing a buffer overflow when the CPU miscomputes a bounds check with the buggy <code class="language-plaintext highlighter-rouge">add</code> instruction. In Part 4.2 we wrote some assembly code (called “shellcode”) that is able to elevate its own privileges using the CPU backdoor and dump the contents of some privileged CSRs to the console.</p> <p>In Part 4.3, we will use the ability to control <code class="language-plaintext highlighter-rouge">pc</code> to cause the CPU to jump to <em>our own input buffer</em> (where the username field goes). We will fill that input buffer with the code from Part 4.2 and send it to the CPU over serial. Then, we will use the buffer overflow to trick the CPU into jumping to the buffer, running the shellcode and granting us machine privileges.</p> <p>The following figure provides an overview of this attack:</p> <p><img src="figures/fuzz-figure3.png" width="65%" id="figure3" /></p> <p>There is a remote Pretty Secure Processor attached to the network running this same program in <code class="language-plaintext highlighter-rouge">PSP_PRIV_USER</code> mode. You can attach to it by hand with the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc localhost 31337
</code></pre></div></div> <p>Give it a try! You should see the same app you are already familiar with. The difference is that <code class="language-plaintext highlighter-rouge">nc</code> connects to a remote CPU that you do not have access to, so you cannot change the code or dump the CSRs without writing an exploit. We are going to fill out the rest of <code class="language-plaintext highlighter-rouge">solve_part4.py</code> to automate sending the shellcode you wrote in <strong>4.2</strong> to the CPU. We will use this script to send this payload over the network to exploit the remote CPU and reveal a privileged flag.</p> <blockquote class="exercise-title"> <p>4-4 Exercise</p> <p>Uncomment lines 24 and 25 in <code class="language-plaintext highlighter-rouge">solve_part4.py</code>. These lines read in a binary file called <code class="language-plaintext highlighter-rouge">dump_flag.bin</code> and write it into a variable called <code class="language-plaintext highlighter-rouge">shellcode</code>. <code class="language-plaintext highlighter-rouge">dump_flag.bin</code> should contain the binary values (the assembled bytes) of the code you wrote in <strong>4.2</strong>.</p> <p>You can use the following to convert the object file (<code class="language-plaintext highlighter-rouge">.o</code>) into a binary dump (<code class="language-plaintext highlighter-rouge">.bin</code>) to be used in the exploit. Assuming your assembly file containing the flag dump routine is called <code class="language-plaintext highlighter-rouge">dump_flag.s</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make                                                              # Assemble the assembly file into a .o object
riscv64-unknown-elf-objcopy -O binary dump_flag.o dump_flag.bin   # Dump the .o into a .bin
</code></pre></div> </div> <p>Now, in Python, you can use the following to read your assembly code in as a bytestring:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shellcode_f=open('part4/dump_flag.bin', 'rb')
shellcode=shellcode_f.read()
</code></pre></div> </div> <p>We want to set <code class="language-plaintext highlighter-rouge">buf</code> (the Python bytestring we send to the CPU) to begin with <code class="language-plaintext highlighter-rouge">shellcode</code>, followed by padding to make it the correct length, followed by <code class="language-plaintext highlighter-rouge">p32(&amp;inputbuf)</code>. This way, the CPU will attempt to execute starting at the first byte of <code class="language-plaintext highlighter-rouge">inputbuf</code>, which contains our <code class="language-plaintext highlighter-rouge">shellcode</code> variable (the flag dumper).</p> <p>The starter code handles most of this for you:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">buf</span> <span class="o">=</span> <span class="n">shellcode</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="p">(</span><span class="n">cyclic_find</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="c1"># cyclic_find() should have been filled in in 4.1
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Replace 0 with the location of inputbuf as displayed by the program
</span></code></pre></div> </div> <p>Now, run <code class="language-plaintext highlighter-rouge">solve_part4.py</code> and you should see the flag printed to the console.</p> <p>Finally, at the top of the program, comment out <code class="language-plaintext highlighter-rouge">io=process(['./run.sh', 'part4'])</code> and uncomment:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Uncomment this to try on the remote CPU:
# io=remote('127.0.0.1', 31337)
</span></code></pre></div> </div> <p>Try <code class="language-plaintext highlighter-rouge">solve_part4.py</code> again and it should dump the flag of the remote CPU! This flag should be different to the one you see when running on the local CPU. Once you have leaked the flag from the remote CPU, you are done with this lab.</p> </blockquote> <blockquote class="discussion-title"> <p>4-5 Discussion Question</p> <p>Include the flag leaked from the remote CPU in your report.</p> </blockquote> <blockquote class="note-title"> <p>Do not worry about cleaning up after your exploit – if the CPU crashes after dumping the flag, that is fine, as long as there is not an unreasonable amount of extra text generated after.</p> <p>To clean your exploit up, you can add a <code class="language-plaintext highlighter-rouge">j .</code> instruction at the end of your flag dumper which will trigger an infinite loop, preventing any crashes or extra text generation.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-3"> <a href="#submission-and-grading-3" class="anchor-heading" aria-labelledby="submission-and-grading-3"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p><code class="language-plaintext highlighter-rouge">git add</code> all the new files you created for Part 4, including any Python or shell scripts you wrote to automate generation of your code. In your report, include the flag you leaked from the remote CPU. Also include in your report where to find the flag dumper method in your <code class="language-plaintext highlighter-rouge">part4</code> directory.</p> <p>Your <code class="language-plaintext highlighter-rouge">solve_part4.py</code> code should attempt to connect to the remote CPU and dump the flag to the console when run.</p> <h1 id="part-5-bug-bounty-optional-10-bonus"> <a href="#part-5-bug-bounty-optional-10-bonus" class="anchor-heading" aria-labelledby="part-5-bug-bounty-optional-10-bonus"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 5: Bug Bounty (Optional, 10% Bonus) </h1> <p>Did you find something wrong with the lab? Were you able to break the CPU in an unintentional way? (Eg. cause a deadlock, found a bug or race condition in other instructions, etc.). Did you find a way to crash our GDB server or a bug in the simulator?</p> <p>Find a bug in the lab materials, let us know about it, and you may be rewarded with bonus points!</p> <blockquote class="note-title"> <p>There is no intended solution for this part – we do not know of any bugs in our lab code.</p> <p>However, we encourage you to try and find some!</p> </blockquote> <p>Non-exhaustive list of possible bugs:</p> <ul> <li>Deadlock condition that causes the CPU to stop executing instructions.</li> <li>Memory corruption vulnerability in our GDB server implementation.</li> <li>Incorrect pipeline hazard forwarding for system control instructions (eg. <code class="language-plaintext highlighter-rouge">ecall</code>, <code class="language-plaintext highlighter-rouge">csrrw</code>, <code class="language-plaintext highlighter-rouge">mret</code>, and the backdoor).</li> <li>Incorrect handling of privilege level for instructions at different privilege levels simultaneously in the pipeline.</li> <li>Simulator errors or incorrect reading of system state (single stepping causes multiple instructions to be executed instead of one, register state read by GDB is incorrect at a given instruction, memory contents as seen by GDB are incorrect or delayed by a few cycles).</li> <li>Vestigial features (such as secure calls/ pointer HMACs, features the core used to support but we disabled – see the GitHub page) were incorrectly disabled and cause bugs.</li> <li>System Management Core exploits (the IPI generator/ IPI ring) – what happens if userspace code triggers a self-IPI?</li> </ul> <p>We are most interested in <strong>unintentional</strong> breaks of the RISC-V specification or issues where the core fails to comply with our stated documentation. An example of a non-issue is how some of our CSRs do not comply with the specification – we intentionally break the ISA in some limited documented situations.</p> <p>Note that what issues qualify for the bonus is at the sole discretion of the instructor.</p> <h1 id="part-6-challenge-problem-optional-no-credit"> <a href="#part-6-challenge-problem-optional-no-credit" class="anchor-heading" aria-labelledby="part-6-challenge-problem-optional-no-credit"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 6: Challenge Problem (Optional, No Credit) </h1> <p>Was this lab too easy for you? Here’s an optional for-fun challenge problem to further test your exploitation skills.</p> <p>There’s another Pretty Secure Processor running on the network, except this time it has a different set of CPU bugs. You’ll need to port your fuzzer <strong>into</strong> your exploit payload. But how do you even get an exploit payload to run in the first place…?</p> <p><code class="language-plaintext highlighter-rouge">nc localhost 31338</code>.</p> <blockquote class="exercise-title"> <p>6-1 Exercise (Optional)</p> <p>Fill in your exploit in <code class="language-plaintext highlighter-rouge">solve_part6.py</code>.</p> </blockquote> <h2 class="no_toc" id="acknowledgements"> <a href="#acknowledgements" class="anchor-heading" aria-labelledby="acknowledgements"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgements </h2> <p>Made by Joseph Ravichandran and Mengjia Yan.</p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
