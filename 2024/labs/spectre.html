<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2024/assets/css/just-the-docs-default.css"> <script src="/2024/assets/js/vendor/lunr.min.js"></script> <script src="/2024/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Spectre Attacks | 6.5950/6.5951</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="Spectre Attacks" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Secure Hardware Design" /> <meta property="og:description" content="Secure Hardware Design" /> <meta property="og:site_name" content="6.5950/6.5951" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Spectre Attacks" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Secure Hardware Design","headline":"Spectre Attacks","url":"/2024/labs/spectre.html"}</script> <!-- End Jekyll SEO tag --> <!-- Cover up the page while CSS is loading to prevent flicker --> <div id="preload-cover"></div> <style> #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#fff; z-index:9999; } @media (prefers-color-scheme: dark) { #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#222326; z-index:9999; } } </style> <script> window.addEventListener('load', function() { var cover = document.getElementById('preload-cover'); cover.style.display = 'none'; }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Feather. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/2024/" class="site-title lh-tight"> 6.5950/6.5951 </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/2024/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2024/calendar.html" class="nav-list-link">Calendar</a></li><li class="nav-list-item"><a href="/2024/lectureReadings.html" class="nav-list-link">Lecture Readings</a></li><li class="nav-list-item"><a href="/2024/paperDiscussion.html" class="nav-list-link">Paper Discussion</a></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Recitations category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/recitations.html" class="nav-list-link">Recitations</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/recitations/cpp.html" class="nav-list-link">CTF of C Programming</a></li><li class="nav-list-item "><a href="/2024/recitations/physical.html" class="nav-list-link">CTF of Physical Attacks</a></li><li class="nav-list-item "><a href="/2024/recitations/riscv.html" class="nav-list-link">Binary Exploitation and RISC-V Warmup</a></li><li class="nav-list-item "><a href="/2024/recitations/formal.html" class="nav-list-link">Formal Verification</a></li></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/labs.html" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/labs/fingerprinting.html" class="nav-list-link">Website Fingerprinting</a></li><li class="nav-list-item "><a href="/2024/labs/cache.html" class="nav-list-link">Cache Attacks</a></li><li class="nav-list-item active"><a href="/2024/labs/spectre.html" class="nav-list-link active">Spectre Attacks</a></li><li class="nav-list-item "><a href="/2024/labs/rowhammer.html" class="nav-list-link">Rowhammer</a></li><li class="nav-list-item "><a href="/2024/labs/aslr.html" class="nav-list-link">ASLR Bypasses</a></li><li class="nav-list-item "><a href="/2024/labs/psp.html" class="nav-list-link">Pretty Secure Processor</a></li><li class="nav-list-item "><a href="/2024/labs/fuzz.html" class="nav-list-link">CPU Fuzzing</a></li><li class="nav-list-item "><a href="/2024/labs/formal.html" class="nav-list-link">CPU Verification</a></li></ul></li><li class="nav-list-item"><a href="/2024/paperReadingGuidance.html" class="nav-list-link">Paper Readings Guidance</a></li><li class="nav-list-item"><a href="/2024/forInstructors.html" class="nav-list-link">For Instructors</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search 6.5950/6.5951" aria-label="Search 6.5950/6.5951" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/2024/labs.html">Labs</a></li> <li class="breadcrumb-nav-list-item"><span>Spectre Attacks</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="spectre-attacks-lab"> <a href="#spectre-attacks-lab" class="anchor-heading" aria-labelledby="spectre-attacks-lab"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Spectre Attacks Lab </h1> <p><strong>Due Date: Mar 21</strong>; Last Updated Date: Feb 14</p> <h2 class="no_toc" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h2> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#part-0-lab-infrastructure" id="markdown-toc-part-0-lab-infrastructure">Part 0: Lab Infrastructure</a></li> <li><a href="#part-1-leaking-kernel-memory-via-flushreload-35" id="markdown-toc-part-1-leaking-kernel-memory-via-flushreload-35">Part 1: Leaking Kernel Memory via Flush+Reload (35%)</a></li> <li><a href="#part-2-basic-spectre-40" id="markdown-toc-part-2-basic-spectre-40">Part 2: Basic Spectre (40%)</a></li> <li><a href="#part-3-advanced-spectre-25" id="markdown-toc-part-3-advanced-spectre-25">Part 3: Advanced Spectre (25%)</a></li> <li><a href="#behind-the-scene-how-this-lab-infrastructure-was-developed" id="markdown-toc-behind-the-scene-how-this-lab-infrastructure-was-developed">Behind the Scene: How this lab infrastructure was developed?</a></li> </ul> <h3 class="no_toc" id="collaboration-policy"> <a href="#collaboration-policy" class="anchor-heading" aria-labelledby="collaboration-policy"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Collaboration Policy </h3> <p>Our full Academic Honesty policy can be found on the <a href="../index.html#collaboration-policy">Course Information page</a> of our website. As a reminder, all 6.5950/6.5951 labs should be completed individually. You may discuss the lab at a high level with a classmate, but you may not work on code together or share any of your code.</p> <h3 class="no_toc" id="getting-started"> <a href="#getting-started" class="anchor-heading" aria-labelledby="getting-started"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h3> <p>Log into your assigned machine. Your credentials and machine information have been emailed to you. It will be one of the <code class="language-plaintext highlighter-rouge">arch-sec-[1-4].csail.mit.edu</code> machines. To connect via ssh, run <code class="language-plaintext highlighter-rouge">ssh username@arch-sec-X.csail.mit.edu</code>.</p> <p>We are using <code class="language-plaintext highlighter-rouge">git</code> for all the labs – instructions for setting up the git repository can be found on the <a href="../labs.html#github">labs page</a>.</p> <p>In addition to submitting code, you are required to submit a PDF lab report containing your answers to Discussion Questions to <a href="https://www.gradescope.com/courses/715149">gradescope</a>. We provide a markdown template in the starter code (<code class="language-plaintext highlighter-rouge">report.md</code>).</p> <h2 id="introduction"> <a href="#introduction" class="anchor-heading" aria-labelledby="introduction"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introduction </h2> <p>In this lab, you will complete the following tasks:</p> <ol> <li>Understand how Spectre works across privilege boundaries.</li> <li>Solve three CTF (capture-the-flag) puzzles with increasing difficulty levels. You will start with implementing the basic Spectre attack. We will then test your understanding of how hardware works by challenging you to implement an advanced Spectre in the last part of this lab.</li> </ol> <h2 id="part-0-lab-infrastructure"> <a href="#part-0-lab-infrastructure" class="anchor-heading" aria-labelledby="part-0-lab-infrastructure"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 0: Lab Infrastructure </h2> <h3 class="no_toc" id="interacting-with-linux-kernel"> <a href="#interacting-with-linux-kernel" class="anchor-heading" aria-labelledby="interacting-with-linux-kernel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Interacting with Linux Kernel </h3> <p>The highlight of this lab is that you will implement your own version of the famous Spectre attack and use it to leak secrets from the Linux kernel, across privilege boundaries. It presents a good opportunity for you to understand the existing technique used to isolate kernelspace from userspace.</p> <p>Our virtual address space is divided into the kernelspace and the userspace. Unprivileged application code resides in the userspace as shown in the figure below. There are several restrictions on the userspace code. The userspace code cannot directly access kernelspace data or directly branch into the kernelspace and execute kernel code. For example, the <code class="language-plaintext highlighter-rouge">load 0xABCD</code> (a kernelspace virtual address) operation will trigger a page permission check failure, or <code class="language-plaintext highlighter-rouge">segmentation fault</code> as reported when running a C program. Similarly, executing the instruction <code class="language-plaintext highlighter-rouge">jump 0x1234</code> will also panic with a segmentation fault.</p> <p>So how can the userspace code interact with the kernelspace and still ensure privilege isolation? The right way is to use kernelspace exposed API interface. When calling a correct kernelspace API, the code jumps to the kernelspace entrypoint (the only place in the kernel allows transition from userspace). The entrypoint code performs tons of work for context switch and then jumps to the requested API function.</p> <p>In our lab infrastructure, we provide a custom Linux kernel module (blue box) sitting in the kernelspace. This kernel module provided a limited interface for userspace code to call into. The module is embedded with vulnerable Spectre gadgets, operates on some secret data (red box), and uses secret data as addresses to access the shared buffer (green box). Read <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed">the section at the end of this handout</a> for more details about how the lab infrastructure is designed. Obviously, your code, residing in the userspace, will not be able to directly access the secret buffer in the kernelspace. Fortunately, we know that the kernelspace and userspace code, when they execute, share all the microarchitectural structures.</p> <div style="text-align:center"><img src="figures/spectre_privilege_boundary.png" width="60%" /></div> <p style="color:gray; font-size: 80%; text-align: center;"><em>Lab Infrastructure Setup</em></p> <!-- In this lab, we have created two data arrays, one called `shared_mem` residing in the userspace, and the other called `partX_secret` residing in the kernel space. The `partX_secret` array contains a secret string that you aim to leak. The custom kernel module is designed to take a user input (usually an integer), perform some simple computation on it, and then perform a read access on the `shared_mem` array. In this lab you will leverage cache side channels to monitor the kernel module's accesses to the `shared_mem` array to leak the secret. --> <h3 class="no_toc" id="the-secret"> <a href="#the-secret" class="anchor-heading" aria-labelledby="the-secret"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Secret </h3> <p>The secret in each part is a string of the form <code class="language-plaintext highlighter-rouge">MIT{some_secret_value}</code>. The string can be up to 64 bytes, including the NULL terminator. You can consider the secret complete once you leak the NULL terminator.</p> <p>The characters in the string may <strong>NOT</strong> be printable ASCII. Your code should be able to leak arbitrary 8-bit secrets byte by byte.</p> <p class="warning">Do not make any assumption about the secret other than it is a <code class="language-plaintext highlighter-rouge">NULL</code> terminated string of length up to 64 bytes (including the <code class="language-plaintext highlighter-rouge">NULL</code> terminator). The secrets will not change from run to run (they are constant for the lifetime of the kernel module). During grading, we may use different secret values to evaluate your implementation.</p> <h3 class="no_toc" id="code-skeleton"> <a href="#code-skeleton" class="anchor-heading" aria-labelledby="code-skeleton"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Code Skeleton </h3> <ul> <li><code class="language-plaintext highlighter-rouge">inc/labspectre.h</code> and <code class="language-plaintext highlighter-rouge">src-common/spectre_lab_helper.c</code> provide a set of utility functions for you to use.</li> <li><code class="language-plaintext highlighter-rouge">src-common/main.c</code> is used in all three parts. The <code class="language-plaintext highlighter-rouge">main</code> function sets up a shared memory region (<code class="language-plaintext highlighter-rouge">shared_memory</code> corresponding to the green box in the figure above) of size <code class="language-plaintext highlighter-rouge">SHD_SPECTRE_LAB_SHARED_MEMORY_SIZE</code> bytes, which is shared between the userspace and kernel. It also sets up a file descriptor for communicating with the kernel module. The technique behind this communication is called <em>procfs write handling</em>, detailed in <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed">the section at the end of this handout</a>.</li> <li><code class="language-plaintext highlighter-rouge">inc/labspectreipc.h</code> contains bindings for the interface to the kernel module from userspace. You do not need to understand this, as our provided code handles the communication with the kernel.</li> <li><code class="language-plaintext highlighter-rouge">part1-src/attacker-part1.c</code> is the file you will modify in Part 1. The method <code class="language-plaintext highlighter-rouge">call_kernel_part1</code> can be used for calling into the kernel module. The code for Part2 and Part 3 follow the exact same pattern.</li> </ul> <h3 class="no_toc" id="compile-test-and-autograde"> <a href="#compile-test-and-autograde" class="anchor-heading" aria-labelledby="compile-test-and-autograde"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compile, Test, and Autograde </h3> <p>This lab will be autograded. After you hand in your code, we will embed different secret strings in the kernel and rerun your code to see whether it effectively leaks these strings. If your code works reliably with the autograder, you should expect no surprise with your grades. Instructions for compiling the code and running the autograder are below.</p> <p>From the root directory, use <code class="language-plaintext highlighter-rouge">make</code> to compile the project. The binaries <code class="language-plaintext highlighter-rouge">part[1-3]</code> will be produced in the same directory (run them by calling <code class="language-plaintext highlighter-rouge">./part[1-3]</code>. The results of your code will be printed to the console – on success you should see the secret leaked from kernel memory printed to the console.</p> <p>An example of the expected output is below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./part1
MIT<span class="o">{</span>part1_secret_value<span class="o">}</span>
</code></pre></div></div> <p>You can invoke the autograder with <code class="language-plaintext highlighter-rouge">./check.py X</code>, where <code class="language-plaintext highlighter-rouge">X</code> is the part to check.</p> <p>An example of the expected output is below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./check.py 1
Checking part 1 ...
You passed 950 of 1000 runs <span class="o">(</span>95.0%<span class="o">)</span>
Success! Good job
</code></pre></div></div> <p>You can check all parts at once with <code class="language-plaintext highlighter-rouge">make</code> and then <code class="language-plaintext highlighter-rouge">./check.py all</code></p> <h2 id="part-1-leaking-kernel-memory-via-flushreload-35"> <a href="#part-1-leaking-kernel-memory-via-flushreload-35" class="anchor-heading" aria-labelledby="part-1-leaking-kernel-memory-via-flushreload-35"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 1: Leaking Kernel Memory via Flush+Reload (35%) </h2> <p>In this part you will set up a cache-based side channel to leak information from the kernel using Flush+Reload.</p> <h3 class="no_toc" id="get-to-know-the-victim"> <a href="#get-to-know-the-victim" class="anchor-heading" aria-labelledby="get-to-know-the-victim"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Get to Know the Victim </h3> <p>The pseudocode for the kernel victim code of Part 1 is shown below.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">victim_part1</span><span class="p">(</span><span class="n">shared_mem</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">secret_data</span> <span class="o">=</span> <span class="n">part1_secret</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
    <span class="n">load</span> <span class="n">shared_mem</span><span class="p">[</span><span class="mi">4096</span> <span class="o">*</span> <span class="n">secret_data</span><span class="p">]</span>
</code></pre></div></div> <p>The victim function takes a pointer <code class="language-plaintext highlighter-rouge">shared_mem</code> and an integer <code class="language-plaintext highlighter-rouge">offset</code> as input. Both variables are passed from the userspace and determined by the attacker, e.g., you. The variable <code class="language-plaintext highlighter-rouge">shared_mem</code> points to the starting of the shared memory region, the green box in the figure above.</p> <p>First, the code loads a secret byte from a secret array named <code class="language-plaintext highlighter-rouge">part1_secret</code>, located inside kernelspace. The byte to leak is chosen by the attacker-controlled <code class="language-plaintext highlighter-rouge">offset</code>. When the <code class="language-plaintext highlighter-rouge">offset</code> is 0, the first secret byte will be loaded; when <code class="language-plaintext highlighter-rouge">offset</code> is 1, the second byte will be loaded, and so on. Next, the victim multiplies the secret byte with <code class="language-plaintext highlighter-rouge">4096</code> and uses the result as an index into the shared memory array. For example, if the secret data was the character ‘A’ (0x41), then the first cache line of the 0x41’th page in the shared memory region will be loaded into the cache.</p> <h3 class="no_toc" id="your-attack-plan"> <a href="#your-attack-plan" class="anchor-heading" aria-labelledby="your-attack-plan"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Your Attack Plan </h3> <p>Recall that the secret is a string up to 64 characters long (including the <code class="language-plaintext highlighter-rouge">NULL</code> terminator). The attacker can leak the secret one byte at a time using Flush+Reload. Reuse your attack strategy from the Part 2 in the cache lab here, with the only difference at step 1, that is, the attacker needs to call the victim code to perform the secret-dependent memory access. Without losing generality, we summarize the attack outline for you below.</p> <ol> <li><strong>Flush</strong> the memory region from the cache using <code class="language-plaintext highlighter-rouge">clflush</code>.</li> <li><strong>Call</strong> the victim method using the desired <code class="language-plaintext highlighter-rouge">offset</code> to leak the secret byte.</li> <li><strong>Reload</strong> the memory region, measure the latency of accessing each address, and use the latency to derive the value of the secret. When the value is <code class="language-plaintext highlighter-rouge">0x00</code> (i.e. <code class="language-plaintext highlighter-rouge">NULL</code>), the attack is complete.</li> </ol> <blockquote class="discussion-title"> <p>1-1 Discussion Question</p> <p>Given the attack plan above, how many addresses need to be flushed in the first step?</p> </blockquote> <h3 class="no_toc" id="allowed-code"> <a href="#allowed-code" class="anchor-heading" aria-labelledby="allowed-code"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Allowed Code </h3> <p>You can define your own helper methods as you desire. You can use any method in <code class="language-plaintext highlighter-rouge">inc/labspectre.h</code> as well as the provided methods in <code class="language-plaintext highlighter-rouge">part1-src/attacker-part1.c</code>.</p> <p>You should only use the provided <code class="language-plaintext highlighter-rouge">call_kernel_part1</code> method to interact with the kernel module. This function takes three arguments: a file descriptor to the kernel module, a pointer to the shared memory region, and an offset. <code class="language-plaintext highlighter-rouge">kernel_fd</code> and <code class="language-plaintext highlighter-rouge">shared_memory</code> can be directly passed to this method without modification. The <code class="language-plaintext highlighter-rouge">offset</code> for a given invocation is up to you.</p> <blockquote class="hint"> <p>Build your attack step-by-step: start by leaking one character first, then try to leak the whole string.</p> </blockquote> <blockquote class="exercise-title"> <p>1-2 Exercise</p> <p>Implement the Flush+Reload attack in <code class="language-plaintext highlighter-rouge">part1-src/attacker-part1.c</code> to leak the secret string. Build the project with <code class="language-plaintext highlighter-rouge">make</code> and run <code class="language-plaintext highlighter-rouge">./part1</code> from the main directory to see if you get the secret. Run <code class="language-plaintext highlighter-rouge">./check.py 1</code> from the main directory to repeat the experiment multiple (5 by defualt) times.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading"> <a href="#submission-and-grading" class="anchor-heading" aria-labelledby="submission-and-grading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Submit your code <code class="language-plaintext highlighter-rouge">part1-src/attacker-part1.c</code> to your assigned Github repo. Full credit will be awarded to solutions that report the correct secret at least 80% of the time, while partial credit will be awarded for solutions which perform worse than that. Each attempt (i.e., each run of <code class="language-plaintext highlighter-rouge">./part1</code>) should take no longer than 30 seconds.</p> <h2 id="part-2-basic-spectre-40"> <a href="#part-2-basic-spectre-40" class="anchor-heading" aria-labelledby="part-2-basic-spectre-40"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 2: Basic Spectre (40%) </h2> <p>Now that Flush+Reload is working, let’s move on to actually implementing a Spectre attack!</p> <h3 class="no_toc" id="get-to-know-the-victim-1"> <a href="#get-to-know-the-victim-1" class="anchor-heading" aria-labelledby="get-to-know-the-victim-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Get to Know the Victim </h3> <p>Below is the pseudocode for Part 2’s victim code. This victim is quite similar to Part 1, except it will only perform the load if the offset is within a specific range (e.g., <code class="language-plaintext highlighter-rouge">offset&lt;4</code>).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">part2_limit</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">victim_part2</span> <span class="p">(</span><span class="n">shared_mem</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="n">secret_data</span> <span class="o">=</span> <span class="n">part2_secret</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
    <span class="n">mem_index</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">*</span> <span class="n">secret_data</span>

    <span class="c1"># to delay the subsequent branch
</span>    <span class="n">flush</span><span class="p">(</span><span class="n">part2_limit</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">part2_limit</span><span class="p">:</span>
        <span class="n">load</span> <span class="n">shared_mem</span><span class="p">[</span><span class="n">mem_index</span><span class="p">]</span>    
</code></pre></div></div> <blockquote class="discussion-title"> <p>2-1 Discussion Question</p> <p>Copy your code in <code class="language-plaintext highlighter-rouge">run_attacker</code> from <code class="language-plaintext highlighter-rouge">attacker-part1.c</code> to <code class="language-plaintext highlighter-rouge">attacker-part2.c</code>. Does your Flush+Reload attack from Part 1 still work? Why or why not?</p> </blockquote> <h3 class="no_toc" id="attack-outline"> <a href="#attack-outline" class="anchor-heading" aria-labelledby="attack-outline"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Attack Outline </h3> <p>Below are the steps required to leak a single byte. You may need to alter your approach to account for system noise.</p> <ol> <li><strong>Train</strong> the branch predictor to speculatively perform the load operation (i.e., take the branch).</li> <li><strong>Flush</strong> the shared memory region from the cache using <code class="language-plaintext highlighter-rouge">clflush</code>.</li> <li><strong>Call</strong> the victim function with an offset beyond the limit, leaking the secret byte during speculative execution.</li> <li><strong>Reload</strong> the memory region, measure the latency of accessing each address, and use the latency to determine the value of the secret.</li> </ol> <blockquote class="hint"> <p>As you’ve observed in previous labs, side channel attacks generally do not work on the first attempt. You should try to use the good practices you have learned from the cache lab when attempting for any microarchitectural attacks. For example,</p> <ul> <li><strong>DO NOT</strong> measure while printing.</li> <li>To improve attack precision, you can repeat measurements multiple times and use statistical methods to decode secret.</li> <li>Try to avoid using systemcall-related functions during attack. Both the <code class="language-plaintext highlighter-rouge">printf</code> and <code class="language-plaintext highlighter-rouge">sleep</code> functions trigger enough noise to seriously destruct your cache state and your branch predictor state.</li> </ul> <p>In addition, here is one more hint specific to the <strong>branch predictor</strong>. Modern processors employ branch predictors with significant complexity. Branch predictors can use global prediction histories, which allow different branches to interfere each other. Besides, the branch predictor is shared between userspace and kernel space. If the speculation is not working as expected, you may need to reduce the number of branches in your attack code.</p> </blockquote> <blockquote class="exercise-title"> <p>2-2 Exercise</p> <p>Implement the Spectre attack in <code class="language-plaintext highlighter-rouge">attacker-part2.c</code> to leak the secret string. Build the project with <code class="language-plaintext highlighter-rouge">make</code> and run <code class="language-plaintext highlighter-rouge">./part2</code> to see if you get the secret. Run <code class="language-plaintext highlighter-rouge">./check.py 2</code> to repeat the experiment multiple (5 by defualt) times.</p> </blockquote> <blockquote class="discussion-title"> <p>2-3 Discussion Question</p> <p>In our example, the attacker tries to leak the values in the array <code class="language-plaintext highlighter-rouge">secret_part2</code>. In a real-world attack, attackers can use Spectre to leak data located in an arbitrary address in the victim’s space. Explain how an attacker can achieve such leakage.</p> </blockquote> <blockquote class="discussion-title"> <p>2-4 Discussion Question</p> <p>Experiment with how often you train the branch predictor. What is the minimum number of times you need to train the branch (i.e. <code class="language-plaintext highlighter-rouge">if offset &lt; part2_limit</code>) to make the attack work?</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-1"> <a href="#submission-and-grading-1" class="anchor-heading" aria-labelledby="submission-and-grading-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>This part is graded in the same way as Part 1. Full credit will be awarded to solutions that report the correct secret at least 80% of the time, while partial credit will be awarded for solutions which perform worse than that. Each attempt (i.e., each run of <code class="language-plaintext highlighter-rouge">./part2</code>) should take no longer than 30 seconds.</p> <h2 id="part-3-advanced-spectre-25"> <a href="#part-3-advanced-spectre-25" class="anchor-heading" aria-labelledby="part-3-advanced-spectre-25"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Part 3: Advanced Spectre (25%) </h2> <p>Now that we’ve got our Spectre attack working, let’s try a harder version of the same problem.</p> <h3 class="no_toc" id="get-to-know-the-victim-2"> <a href="#get-to-know-the-victim-2" class="anchor-heading" aria-labelledby="get-to-know-the-victim-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Get to Know the Victim </h3> <p>Below is the pseudocode for Part 3:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">part3_limit</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">victim_part3</span> <span class="p">(</span><span class="n">shared_mem</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">part3_limit</span><span class="p">:</span>
        <span class="n">false_dependency</span> <span class="o">=</span> <span class="n">lengthy</span> <span class="n">computation</span> <span class="c1"># the computation result is 0
</span>        <span class="n">secret_data</span> <span class="o">=</span> <span class="n">part3_secret</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
        <span class="n">mem_index</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">*</span> <span class="n">secret_data</span>
        <span class="n">load</span> <span class="n">shared_mem</span><span class="p">[</span><span class="n">mem_index</span> <span class="o">+</span> <span class="n">false_dependency</span><span class="p">]</span>
</code></pre></div></div> <p>There are two key differences in the victim code compared to Part 2. First, the victim no longer flushes the limit variable (<code class="language-plaintext highlighter-rouge">partX_limit</code>) before the branch. Second, we have added a false dependency before the memory access, making the memory access start later in the speculation window.</p> <p>If you copy <code class="language-plaintext highlighter-rouge">run_attacker</code> from Part 2, you should see that your attack does not work with the new victim. This is because in the modified victim code, the memory access instruction we try to monitor may not be issued speculatively for three reasons:</p> <ol> <li>The speculation window becomes shorter. The speculation window starts at the cycle the branch (<code class="language-plaintext highlighter-rouge">if offset &lt; part3_limit</code>) enters the processor, and ends at the cycle when the branch condition is resolved. If the <code class="language-plaintext highlighter-rouge">part3_limit</code> variable is cached, it will take a very short time to obtain its value, detect it is a branch misprediction, and squash the instructions after this branch. As a result, the speculative window becomes shorter.</li> <li>The issue time of the secret-dependent memory access is delayed. Due to the data dependency between the <code class="language-plaintext highlighter-rouge">false_dependency</code> line and the <code class="language-plaintext highlighter-rouge">load shared_mem</code> line, the secret-dependent memory access can only be issued after the variable <code class="language-plaintext highlighter-rouge">false_dependency</code> is computed. It is possible that the branch condition is resolved before the speculative load even executes.</li> <li>There is a hidden source of timing delay due to TLB misses. Feel free to refer to <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed">the section at the end of this handout</a> for more information. You do not need to understand this factor for making your attack work. <!-- 1. The access to the shared region triggers a TLB miss. As perviously discussed, due to the design details of the custom kernel, the address mapping for the shared region will not be resident in the TLB upon entering the kernel. Different from Part 1 and Part 2, here we do not force page walks before running the vulnerable code. As a result, the memory load must first perform a page table walk, increasing the time it takes to perform the load (thereby increasing the chance that the speculative window closes before your address makes it to the cache). --></li> </ol> <blockquote class="hint"> <p>To make your attack work, you will need to find a way to increase the speculation window such that the speculative load has a higher chance of occuring. Note that you <em>cannot</em> change the long latency memory address dependency. Similar as before, use the good practices for microarchitectural attacks: <em>do not</em> use systemcall-related functions during attack, such as <code class="language-plaintext highlighter-rouge">printf</code> and <code class="language-plaintext highlighter-rouge">sleep</code>.</p> </blockquote> <blockquote class="warning-title"> <p>Note</p> <p>If your implementation from Part 2 can pass the test for Part 3, congratulations and please reach out to us! We have designed this part to make basic Spectre attack implementations work ineffectively, and we’d be curious to learn how you made it work in one shot.</p> </blockquote> <blockquote class="exercise-title"> <p>3-1 Exercise</p> <p>Optimize the attack in <code class="language-plaintext highlighter-rouge">attacker-part3.c</code> to leak the secret string. Build the project with <code class="language-plaintext highlighter-rouge">make</code> and run <code class="language-plaintext highlighter-rouge">./part3</code> to see if you get the secret. Run <code class="language-plaintext highlighter-rouge">./check.py 3</code> to repeat the experiment multiple (5 by defualt) times.</p> </blockquote> <blockquote class="discussion-title"> <p>3-2 Discussion Question</p> <p>Describe the strategy you employed to extend the speculation window of the target branch in the victim.</p> </blockquote> <blockquote class="discussion-title"> <p>3-3 Discussion Question</p> <p>Assume you are an attacker looking to exploit a new machine that has the same kernel module installed as the one we attacked in this part. What information would you need to know about this new machine to port your attack? Could it be possible to determine this information experimentally? Briefly describe in 5 sentences or less.</p> </blockquote> <h3 class="no_toc" id="submission-and-grading-2"> <a href="#submission-and-grading-2" class="anchor-heading" aria-labelledby="submission-and-grading-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Submission and Grading </h3> <p>Full credit will be awarded to solutions that report the correct secret at least <strong>20%</strong> of the time, while partial credit will be awarded for solutions which perform worse than that. Each attempt (i.e., each run of <code class="language-plaintext highlighter-rouge">./part3</code>) should take no longer than 10 minutes. We will give partial credit if the attack can recover some part of the secret string.</p> <p>You can check all parts at once with <code class="language-plaintext highlighter-rouge">make</code> and then <code class="language-plaintext highlighter-rouge">./check.py all</code></p> <p>As always, do not forget to include answers to the discussion questions in your lab report and submit the report to gradescope.</p> <h2 id="behind-the-scene-how-this-lab-infrastructure-was-developed"> <a href="#behind-the-scene-how-this-lab-infrastructure-was-developed" class="anchor-heading" aria-labelledby="behind-the-scene-how-this-lab-infrastructure-was-developed"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Behind the Scene: How this lab infrastructure was developed? </h2> <p>For those who are curious, here is a brief description of how this lab infrastructure was developped. The victims you are interacting with are part of a custom kernel module. You can find the source code of this kernel module in <code class="language-plaintext highlighter-rouge">module-src/labspectrekm.c</code>. The communication between the userspace and the kernel module is handled using a technique called <em>procfs write handling</em>. Specifically, whenever the userspace code writes to a file (i.e., <code class="language-plaintext highlighter-rouge">/proc/labspectre-victim</code>), a procfs write handler (i.e., <code class="language-plaintext highlighter-rouge">spectre_lab_victim_write</code> function in <code class="language-plaintext highlighter-rouge">module-src/labspectrekm.c</code>) in the kernel module will start to execute, using the written data (i.e., the <code class="language-plaintext highlighter-rouge">local_cmd</code> variable in <code class="language-plaintext highlighter-rouge">call_kernel_partX</code> functions) as the <code class="language-plaintext highlighter-rouge">userbuf</code> arguments.</p> <p>On the lab machine, SMAP (supervisor mode access prevention) and SMEP (supervisor mode execution prevention) are both on, which means that the kernel cannot directly read or execute userspace memory. You may wonder, in this case, how the kernel can read the <code class="language-plaintext highlighter-rouge">shared_mem</code> array, which is located in userspace. This is done by temporarily remapping an alias of the shared memory region into the kernel space. What we end up with is two different virtual addresses, one in the userspace and one the kernel space, both mapping to the same physical address. This is similar to what we have seen in Part 2 of the cache lab, where two virtual addresses in two processes are mapped to the same physical address.</p> <p>The interaction between the kernel module and the userspace code involves context switches. When the userspace code calls the kernel module (via the <code class="language-plaintext highlighter-rouge">write</code> syscall), the processor transitions from the userspace to the kernelspace, which will flush some microarchitecture structures, such as TLBs. The custom kernel module will then create an alias mapping for the shared memory region and execute the requested function. Before returning to the userspace, it will unmap the shared region. Therefore, every time the kernel module is called, the first accesses to each page will incur TLB misses. In Parts 2, we deliberately prevent TLB misses to make your attack easier by forcing page walks before performing any secret-dependent memory accesses. In Part 3, these redundant accesses are removed. You will need to craft an advanced Spectre attack that can succeed despite the added latency due to TLB misses. So in Part 3, in addition to the false dependency, the TLB misses also contribute to the extra latency.</p> <h2 class="no_toc" id="acknowledgements"> <a href="#acknowledgements" class="anchor-heading" aria-labelledby="acknowledgements"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgements </h2> <p>Contributors: Joseph Ravichandran, Mengjia Yan, Peter Deutsch.</p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
