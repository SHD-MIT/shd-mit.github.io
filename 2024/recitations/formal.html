<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2024/assets/css/just-the-docs-default.css"> <script src="/2024/assets/js/vendor/lunr.min.js"></script> <script src="/2024/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Formal Verification | 6.5950/6.5951</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="Formal Verification" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Secure Hardware Design" /> <meta property="og:description" content="Secure Hardware Design" /> <meta property="og:site_name" content="6.5950/6.5951" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Formal Verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Secure Hardware Design","headline":"Formal Verification","url":"/2024/recitations/formal.html"}</script> <!-- End Jekyll SEO tag --> <!-- Cover up the page while CSS is loading to prevent flicker --> <div id="preload-cover"></div> <style> #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#fff; z-index:9999; } @media (prefers-color-scheme: dark) { #preload-cover { position:fixed; height:100%; width:100%; top:0; left:0; background:#222326; z-index:9999; } } </style> <script> window.addEventListener('load', function() { var cover = document.getElementById('preload-cover'); cover.style.display = 'none'; }); </script> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Feather. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/2024/" class="site-title lh-tight"> 6.5950/6.5951 </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/2024/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2024/calendar.html" class="nav-list-link">Calendar</a></li><li class="nav-list-item"><a href="/2024/lectureReadings.html" class="nav-list-link">Lecture Readings</a></li><li class="nav-list-item"><a href="/2024/paperDiscussion.html" class="nav-list-link">Paper Discussion</a></li><li class="nav-list-item active"><a href="#" class="nav-list-expander" aria-label="toggle links in Recitations category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/recitations.html" class="nav-list-link">Recitations</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/recitations/cpp.html" class="nav-list-link">CTF of C Programming</a></li><li class="nav-list-item "><a href="/2024/recitations/physical.html" class="nav-list-link">CTF of Physical Attacks</a></li><li class="nav-list-item "><a href="/2024/recitations/riscv.html" class="nav-list-link">Binary Exploitation and RISC-V Warmup</a></li><li class="nav-list-item active"><a href="/2024/recitations/formal.html" class="nav-list-link active">Formal Verification</a></li></ul></li><li class="nav-list-item"><a href="#" class="nav-list-expander" aria-label="toggle links in Labs category"> <svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg> </a><a href="/2024/labs.html" class="nav-list-link">Labs</a><ul class="nav-list "><li class="nav-list-item "><a href="/2024/labs/fingerprinting.html" class="nav-list-link">Website Fingerprinting</a></li><li class="nav-list-item "><a href="/2024/labs/cache.html" class="nav-list-link">Cache Attacks</a></li><li class="nav-list-item "><a href="/2024/labs/spectre.html" class="nav-list-link">Spectre Attacks</a></li><li class="nav-list-item "><a href="/2024/labs/rowhammer.html" class="nav-list-link">Rowhammer</a></li><li class="nav-list-item "><a href="/2024/labs/aslr.html" class="nav-list-link">ASLR Bypasses</a></li><li class="nav-list-item "><a href="/2024/labs/psp.html" class="nav-list-link">Pretty Secure Processor</a></li><li class="nav-list-item "><a href="/2024/labs/fuzz.html" class="nav-list-link">CPU Fuzzing</a></li><li class="nav-list-item "><a href="/2024/labs/formal.html" class="nav-list-link">CPU Verification</a></li></ul></li><li class="nav-list-item"><a href="/2024/paperReadingGuidance.html" class="nav-list-link">Paper Readings Guidance</a></li><li class="nav-list-item"><a href="/2024/forInstructors.html" class="nav-list-link">For Instructors</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search 6.5950/6.5951" aria-label="Search 6.5950/6.5951" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/2024/recitations.html">Recitations</a></li> <li class="breadcrumb-nav-list-item"><span>Formal Verification</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h2 class="no_toc" id="table-of-contents"> <a href="#table-of-contents" class="anchor-heading" aria-labelledby="table-of-contents"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Table of Contents </h2> <ul id="markdown-toc"> <li><a href="#the-big-picture" id="markdown-toc-the-big-picture">The Big Picture</a> <ul> <li><a href="#model-checking--cover-all-reachable-states" id="markdown-toc-model-checking--cover-all-reachable-states">Model Checking = Cover All Reachable States</a></li> <li><a href="#symbolic-execution-using-rosette" id="markdown-toc-symbolic-execution-using-rosette">Symbolic Execution Using Rosette</a></li> <li><a href="#how-does-rosette-work-internally" id="markdown-toc-how-does-rosette-work-internally">How does Rosette work internally?</a></li> </ul> </li> <li><a href="#verifying-the-tiny-cpu" id="markdown-toc-verifying-the-tiny-cpu">Verifying The Tiny CPU</a> <ul> <li><a href="#tiny-cpu-specification" id="markdown-toc-tiny-cpu-specification">Tiny CPU Specification</a></li> <li><a href="#from-rtl-to-rosette" id="markdown-toc-from-rtl-to-rosette">From RTL to Rosette</a></li> <li><a href="#how-does-yosysknox-work-internally" id="markdown-toc-how-does-yosysknox-work-internally">How does “yosys+knox” work internally?</a></li> </ul> </li> <li><a href="#learn-rosette-syntax" id="markdown-toc-learn-rosette-syntax">Learn Rosette Syntax</a> <ul> <li><a href="#rosette-and-racket" id="markdown-toc-rosette-and-racket">Rosette and Racket</a></li> <li><a href="#define-functions-call-functions-and-define-variables" id="markdown-toc-define-functions-call-functions-and-define-variables">Define Functions, Call Functions, and Define Variables</a></li> <li><a href="#include-libraries" id="markdown-toc-include-libraries">Include libraries</a></li> <li><a href="#struct" id="markdown-toc-struct">Struct</a></li> <li><a href="#bitvector-and-vector" id="markdown-toc-bitvector-and-vector">Bitvector and vector</a></li> <li><a href="#printf" id="markdown-toc-printf">Printf</a></li> <li><a href="#branch-and-loops" id="markdown-toc-branch-and-loops">Branch and Loops</a></li> </ul> </li> <li><a href="#hands-on-exercise" id="markdown-toc-hands-on-exercise">Hands-on Exercise</a> <ul> <li><a href="#exercise-1-interact-with-tiny-cpu-in-rosette" id="markdown-toc-exercise-1-interact-with-tiny-cpu-in-rosette">Exercise 1: Interact With Tiny CPU in Rosette</a></li> <li><a href="#exercise-2-encode-specification-into-rosette" id="markdown-toc-exercise-2-encode-specification-into-rosette">Exercise 2: Encode Specification into Rosette</a></li> <li><a href="#exercise-3-use-assert-to-express-implementation-matches-specification" id="markdown-toc-exercise-3-use-assert-to-express-implementation-matches-specification">Exercise 3: Use <code class="language-plaintext highlighter-rouge">assert</code> to Express “Implementation Matches Specification”</a></li> </ul> </li> </ul> <!-- Frequent Q&As: - Is spec simulated each cycle impl simulated? No, only when impl commit - Does spec has latency? No --> <h1 class="no_toc" id="formal-verification-of-rtl-implementation"> <a href="#formal-verification-of-rtl-implementation" class="anchor-heading" aria-labelledby="formal-verification-of-rtl-implementation"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Formal Verification of RTL Implementation </h1> <p>Formal verification is a well-explored research area and has been shown to be effective in hardware verification. In this recitation, we will provide an overview of one type of formal verification technique, called bounded model checking. You will learn how to use a powerful toolchain that combines Yosys, Rosette, and several scripts to perform bounded model checking and find processor bugs on RTL code. It will give you a taste on how to perform automatic bug finding and understand the challenges of this topic.</p> <p>We will start by giving you the big picture of formal verification and how the toolchain will help acheive our goals. Next, we will go through the basics of Rosette, which programs using a functional programming lanaguge. It might be a pain to swtich from C/Python to a functional programming lanague, but we will go through the start code with you and get you fully prepared. Finally, you will try to play with the toolchain and automatically find bugs as you like.</p> <!-- We will try out a powerful framework that can formally verify hardware modules behaving exactly as we expect. We will use it to find bugs in a tiny cpu. --> <h3 class="no_toc" id="getting-started"> <a href="#getting-started" class="anchor-heading" aria-labelledby="getting-started"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Getting Started </h3> <p>The starter code of the recitation is <a href="https://github.com/CSAIL-Arch-Sec/SHD-FormalVerificationRec">here</a>.</p> <p>It could be run on our lab machine <code class="language-plaintext highlighter-rouge">unicorn.csail.mit.edu</code>. Log in with the same user account as previous labs.</p> <p>Alternatively, you can use the docker file provided in the starter code to run the lab locally. Instructions to run the docker are provided <a href="../labs.html#alternative-docker-environment">here</a>. (The docker image takes ~20 minutes to build.)</p> <h2 id="the-big-picture"> <a href="#the-big-picture" class="anchor-heading" aria-labelledby="the-big-picture"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Big Picture </h2> <p>The general idea of formal verification is far from complex. As shown in the picture below, we have 1) an <strong>implementation</strong> of the hardware (e.g., verilog code, miniSpec code), which can be complex and potentially buggy, and 2) a clearly-defined <strong>specification</strong> of what we expect the hardware to do, like the RISC-V manual we use in lab6.A. The goal of formal verification is to check the implementation matches the specification under <strong>all possible inputs</strong> to the hardware.</p> <!-- The general idea of formal verification is very straightforward. First, we have an **implementation** of the hardware (e.g., verilog code, miniSpec code), which can be complex and potentially buggy. Second, we have a clean **specification** of what we expect the hardware to do, like the RISC-V manual we use in lab6. Then, we will verify that the implementation matches the specification under **all possible execution traces**. --> <!-- This verification process can be complicated but fortunately, we have this recitation to teach you everything about it! Before we get started, be sure to put this big picture of the framework in mind: --> <p><img src="figures/formal-1.png" width="600" /></p> <!-- One approach is to ask a hardware experts to stare at the code and figure out the bug, which provides no guarantees. --> <!-- Another approach is to do exhaustive search, but we may suffer from serious scalability issues, especially when the input space is huge. In this recitation, we will use symbolic execution and leverage some help from advanced mathmatical techniques (SMT solvers) to automatically search the space in an efficient and smart way. --> <!-- As we go through this recitation, we will dig into the details of this framework by learning a few powerful and open-source tools inside the magic toolbox that can automatically conduct the verification. In the end, you will be able to use this framework to verify a verilog implementation of a tiny_cpu. --> <!-- ## "Formal" = Cover All Possible Executions --> <h3 id="model-checking--cover-all-reachable-states"> <a href="#model-checking--cover-all-reachable-states" class="anchor-heading" aria-labelledby="model-checking--cover-all-reachable-states"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Model Checking = Cover All Reachable States </h3> <p>We consider our hardware as a state machine, the concept of model checking is to check for all the reachable states of the system to satisfy certain properties/specifications. One approach is to do exhaustive search, but we may suffer from serious scalability issues, especially when the input space is huge. In this recitation, we will use a <em>symbolic execution engine</em> and leverage some help from advanced mathmatical techniques (SMT solvers) to automatically search the space in an efficient and smart way. Let us introduce our first tool, a programming language, called <a href="https://docs.racket-lang.org/rosette-guide/index.html">Rosette</a>.</p> <p>Rosette is a language extension based on <a href="https://racket-lang.org">Racket</a> to add the symbolic execution feature. Language extension is similar to a library in C/python, but can provide more syntax-related features in addition to extra functions. We will explain how Rosette works using the following example.</p> <!-- Basically speaking, "formally verify a design" just means "the design is correct under all possible executions". **Covering all possible executions is our key challenge and we will introduce our first tool, a programming language, [Rosette](https://docs.racket-lang.org/rosette-guide/index.html) to solve it.** Let me show you how we cover all possible execution with Rosette. --> <!-- ### Example: use Rosette to cover all possible executions --> <h3 id="symbolic-execution-using-rosette"> <a href="#symbolic-execution-using-rosette" class="anchor-heading" aria-labelledby="symbolic-execution-using-rosette"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Symbolic Execution Using Rosette </h3> <blockquote class="exercise-title"> <p>Exercise</p> <p>To test the code by yourself, run <code class="language-plaintext highlighter-rouge">cd RosetteExample &amp;&amp; racket example.rkt</code></p> </blockquote> <blockquote class="hint-title"> <p>Broken Environment</p> <p>In case the command above returns <code class="language-plaintext highlighter-rouge">-bash: racket: command not found</code> on <code class="language-plaintext highlighter-rouge">unicorn</code>, try <code class="language-plaintext highlighter-rouge">source /knox/envSetup.sh</code> to set environment variables. (This should not happen normally because this source command should be run automatically when you log in.)</p> </blockquote> <p>Here is a function that can trigger some forbidden execution path under some non-trivial condition:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">rosette</span>                <span class="c1">; # Here is a python version:</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>              <span class="c1">; def f(x, y):</span>
  <span class="p">(</span><span class="k">when</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span> <span class="c1">;   if (x+10)*2 == y:</span>
    <span class="p">(</span><span class="nf">assert</span> <span class="no">#f</span><span class="p">)))</span>            <span class="c1">;     assert False</span>

<span class="p">(</span><span class="nf">f</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span>                     <span class="c1">; f(1, 10)</span>
</code></pre></div></div> <p>We want to check this program (corresponding to the implementation in the big picture figure) against a specification, which says the program does not trigger an assertion. We will need to check it against all the inputs.</p> <p>Here, rather than using concrete input values, we use Rosette to declare the inputs as symbolic values and ask Rosette to check all possible inputs. No worries about the syntax for now, we will go through the syntax in detail in a few minutes. <!-- how we can check the function with all possible inputs: --></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(define-symbolic x integer?)
(define-symbolic y integer?)
(verify (f x y))
</code></pre></div></div> <p>When running the <code class="language-plaintext highlighter-rouge">verify</code> command, Rosette will do some magic internally and generate an input (<code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code>) that fails the function:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(model
 [x 0]
 [y 20])
</code></pre></div></div> <p>Excellent tool! Using Rosette, we are capable to write a program embedded with <code class="language-plaintext highlighter-rouge">assert</code> (a state that we should not reach) and ask Rosette to automatically generate the inputs that can lead us to that invalid state. <!-- We are now capable to write a function with `assert` and ask Rosette to automatically check all `assert` are satisfied. --> We call the above output a <strong>counterexample</strong>.</p> <!-- ### What is happening inside Rosette? Skipping this part will not prevent you working on the recitation. But read on if you are curious. At high level, Rosette can compile a program with some of the parts represented as symbolic values, rather than concrete values. For example, if you have a statement `c=a+b`. If using concrete values, `a=1` and `b=1`, we will directly reduce the formula and get `c=3`. However, if we consider things as symbolic values, the whole formula will be maintained, and we will remember `c` as `a+b`. You may feel symbolic formula basically does nothing, but actually when things become complex, there are plenty of opportunities to reduce the formula. For example, if later we hit another statement `d=c-b`. The symbolic execution engine will be smart enough to figure out `d=a` for whatever combinations of `a` and `b`. Basically, using the techniques above, Rosette will compile the whole program into one or multiple symbolic formulas. As such, the tool converts a bug finding problem (i.e., how to trigger `assertion`) into a pure math problem. It then solves the problem using some math tools (usually refered to as SMT solvers). You do not need to know how SMT solvers work. You can think them as powerful tools to solve equations. --> <!-- ### How will Rosette contribute to the framework? --> <!-- How will this help with our goal of the hardware verification framework? Check our framework figure above, we can basically translate both implementation and specification into a Rosette function and use an `assert` to express that "they match each other". --> <h3 id="how-does-rosette-work-internally"> <a href="#how-does-rosette-work-internally" class="anchor-heading" aria-labelledby="how-does-rosette-work-internally"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How does Rosette work internally? </h3> <blockquote class="note-title"> <p>Skipping this part will not prevent you working on the recitation. But read on if you are curious.</p> </blockquote> <p><strong>Symbolic Execution.</strong> The first technique Rosette uses is called Symbolic Execution. Normally, a program will execute on concrete input values. For example, <code class="language-plaintext highlighter-rouge">(* (+ 1 10) 2)</code> will return 22. However, you will forget how 22 is computed. Executing on symbolic value, instead, will remember how a new value is computed from the symbolic input values by <strong>using a syntax tree as the return value</strong>. For example, running the following program in Rosette will print exactly <code class="language-plaintext highlighter-rouge">(* (+ x 10) 2)</code>:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-symbolic</span> <span class="nv">x</span> <span class="nv">integer?</span><span class="p">)</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div> <p>With symbolic execution, every time a branch is met, the condition of the branch is actually an expression of symbolic values that encodes the syntax tree that computes this condition. Since we do not know whether the symbolic expression is true or false, we will execute both sides of the branch. But we have to use an extra data structure to remember the symbolic expressions of all branches in the history and remember which direction we took. This extra data structure is called <strong>path condition</strong> that can be extracted using <code class="language-plaintext highlighter-rouge">(vc-assumes (vc))</code> in Rosette. This following example will print <code class="language-plaintext highlighter-rouge">Path1: (= 0 x)</code> and <code class="language-plaintext highlighter-rouge">Path2: (! (= 0 x))</code></p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-symbolic</span> <span class="nv">x</span> <span class="nv">integer?</span><span class="p">)</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="p">(</span><span class="nf">~a</span> <span class="s">"Path1: "</span> <span class="p">(</span><span class="nf">vc-assumes</span> <span class="p">(</span><span class="nf">vc</span><span class="p">))</span> <span class="s">"\n"</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">printf</span> <span class="p">(</span><span class="nf">~a</span> <span class="s">"Path2: "</span> <span class="p">(</span><span class="nf">vc-assumes</span> <span class="p">(</span><span class="nf">vc</span><span class="p">))</span> <span class="s">"\n"</span><span class="p">)))</span>
</code></pre></div></div> <p>Finally, every time you make an assertion under a specific path, the path condition will be combined with the asserted expression. This combined expression will be used to determine whether the assert true will be guaranteed. For example, the following code will print <code class="language-plaintext highlighter-rouge">(|| (! (= 0 x)) (= x y))</code>, which is the condition that the assert true will be guaranteed.</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">define-symbolic</span> <span class="nv">x</span> <span class="nv">integer?</span><span class="p">)</span>
<span class="p">(</span><span class="nf">define-symbolic</span> <span class="nv">y</span> <span class="nv">integer?</span><span class="p">)</span>
<span class="p">(</span><span class="k">when</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">assert</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nf">vc-asserts</span> <span class="p">(</span><span class="nf">vc</span><span class="p">)))</span>
</code></pre></div></div> <p>In summary, with the techniques of <strong>syntax tree expression</strong> and <strong>path condition</strong>, symbolic execution converts assertions in the program into symbolic expressions that need to be asserted to be true.</p> <p><strong>SMT solver.</strong> The second part of Rosette is about using an SMT solver as the backend. With symbolic execution, the problem of finding a forbidden execution path is converted to a pure mathematical problem. Rosette will send the symbolic expression (i.e. a logic formula) to a logic solver (i.e. a SMT solver) and the SMT solver will find a binding of symbolic values that trigger the forbidden execution path. For example</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(model
 [x 0]
 [y 20])
</code></pre></div></div> <p>shows a binding that <code class="language-plaintext highlighter-rouge">x</code> is 0 and <code class="language-plaintext highlighter-rouge">y</code> is 20.</p> <blockquote class="note-title"> <p>In the rest of the recitation, free feel to print out symbolic expressions and path conditions to get a sense of what Rosette is doing.</p> </blockquote> <h2 id="verifying-the-tiny-cpu"> <a href="#verifying-the-tiny-cpu" class="anchor-heading" aria-labelledby="verifying-the-tiny-cpu"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Verifying The Tiny CPU </h2> <p>This is probably a good time to introduce our example CPU that we try to verify: the Tiny CPU. Throughout this recitation, we will use it to demonstrate how to use the model checking framework.</p> <h3 id="tiny-cpu-specification"> <a href="#tiny-cpu-specification" class="anchor-heading" aria-labelledby="tiny-cpu-specification"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Tiny CPU Specification </h3> <p>We will verify a verilog implementation of tiny_cpu matches its specification as below.</p> <p><img src="figures/formal-2.png" width="600" /></p> <p>The tiny_cpu cannot really be simpler. It uses 4 bits for all registers. It has two general purpose-register <code class="language-plaintext highlighter-rouge">R1</code> and <code class="language-plaintext highlighter-rouge">R2</code>, as well as a <code class="language-plaintext highlighter-rouge">pc</code> register. At each cycle, it reads an instruction from a 16-entry instruction memory and decodes&amp;executes it as 3 possible instructions, INC, ACC, and NOP, as shown in the table above. Then, <code class="language-plaintext highlighter-rouge">pc</code> will be incremented by 1. (<code class="language-plaintext highlighter-rouge">pc</code> can overflow from 0xf to 0x0.) There is no data memory.</p> <p>We implement it in verilog as a multi-cycle cpu (<code class="language-plaintext highlighter-rouge">tiny_cpu/tiny_cpu.v</code>). It executes instructions one by one. It takes 2 cycles to execute an INC instruction, 3 cycles to execute an ACC instruction, and 1 cycle to execute an NOP instruction. Here is the internal stage transition in the implementation:</p> <p><img src="figures/formal-3.png" width="450" /></p> <p>At the commit stage, it will increment the <code class="language-plaintext highlighter-rouge">pc</code> and update <code class="language-plaintext highlighter-rouge">R1</code>, <code class="language-plaintext highlighter-rouge">R2</code> according to the instruction.</p> <h3 id="from-rtl-to-rosette"> <a href="#from-rtl-to-rosette" class="anchor-heading" aria-labelledby="from-rtl-to-rosette"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> From RTL to Rosette </h3> <!-- Now that we have learned a powerful tool Rosette, the rest of the work is mostly engineering efforts to take full advantage of Rosette. Basically, we will translate both implementation and specification into Rosette. --> <p><!-- and construct an `assert` to express that "they match each other". --></p> <p>We have seen that the Rosette is a functional programming language, far different from our RTL code. Therefore, the first step is to lift the RTL code that we are trying to verify to Rosette. You can view this process as a translation process from one language to another. For this purpose, we use a toolchain <strong>“<a href="https://yosyshq.net/yosys/">yosys</a>+<a href="https://github.com/anishathalye/knox">knox</a>“</strong> developed by <a href="https://www.anish.io">Anish Athalye</a> from the PDOS group at MIT.</p> <p>Take our tiny_cpu as an example, run <code class="language-plaintext highlighter-rouge">./scripts/v2rkt.sh</code> will convert the <code class="language-plaintext highlighter-rouge">tiny_cpu/tiny_cpu.v</code> into <code class="language-plaintext highlighter-rouge">generated_src/tiny_cpu.rkt</code>. The converted Rosette code provides a few APIs to simulate the tiny_cpu.</p> <p>To demonstrate how these APIs can be used, we provide <code class="language-plaintext highlighter-rouge">src/impl.rkt</code>. It will simulate the tiny_cpu for 20 cycles and print its state at each cycle. <!-- Please execute the file with command `racket src/impl.rkt` (Keep `pwd` in the `framework` folder). --></p> <blockquote class="exercise-title"> <p>Exercise</p> <p>Run <code class="language-plaintext highlighter-rouge">./scripts/v2rkt.sh</code> to convert Verilog to Rosette. Then, simulate tiny_cpu for 20 cycles with <code class="language-plaintext highlighter-rouge">racket src/impl.rkt</code>.</p> </blockquote> <h3 id="how-does-yosysknox-work-internally"> <a href="#how-does-yosysknox-work-internally" class="anchor-heading" aria-labelledby="how-does-yosysknox-work-internally"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> How does “yosys+knox” work internally? </h3> <p>Here is the story of how this toolchain is created. Anish, the author of knox was looking for a way to convert Verilog code to Rosette so that he could symbolically execute the Verilog code to conduct some interesting research.</p> <p>Traditionally, the most direct method to translate Verilog code to a simulator code involves parsing the Verilog into some netlist representation and using the netlist to generate the target code in the new language. There are many compilers (or more precisely, synthesis tools) available to do this, yosys is one of them. But even with the help of them, you need to deal with a lot of tedious syntax problems of Racket.</p> <p>Anish, instead, <del>used chatGPT to do that. End of Story.</del> tried to find a simpler way. He realized one target code called SMT2 that yosys can translate Verilog to, looks very similar to Racket code. (Check the file <code class="language-plaintext highlighter-rouge">generated_src/tiny_cpu.smt2</code> by yourself.) Then, he decided to <strong>teach Racket to understand SMT2 code</strong>!</p> <p>Remember that we say Rosette is a language extension to Racket? Anish wrote a new extension to Racket called yosys so that Racket can understand the syntax of SMT2 code and define some Racket functions from it. These functions are the APIs <code class="language-plaintext highlighter-rouge">generated_src/tiny_cpu.rkt</code> provides to us. Actually, the only difference between <code class="language-plaintext highlighter-rouge">generated_src/tiny_cpu.rkt</code> and <code class="language-plaintext highlighter-rouge">generated_src/tiny_cpu.smt2</code> is an extra line of <code class="language-plaintext highlighter-rouge">#lang yosys</code> that imports the yosys extension.</p> <p>Hoepfully now you can understand better about “Language extension is similar to a library in C, but can provide more syntax-related features in addition to extra functions”. It can really do some magic.</p> <h2 id="learn-rosette-syntax"> <a href="#learn-rosette-syntax" class="anchor-heading" aria-labelledby="learn-rosette-syntax"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Learn Rosette Syntax </h2> <p>The transition from a C-programming style to a functional-programming style like Rosette can be painful. But hopefully, you are motivated enough to tackle this challenge so far. We will guide you to read through <code class="language-plaintext highlighter-rouge">src/impl.rkt</code> to warm you up.</p> <h3 id="rosette-and-racket"> <a href="#rosette-and-racket" class="anchor-heading" aria-labelledby="rosette-and-racket"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Rosette and Racket </h3> <p>Firstly, you might notice the filename extension is <code class="language-plaintext highlighter-rouge">.rkt</code>. This is because technically, most code here is not <a href="https://docs.racket-lang.org/rosette-guide/index.html">Rosette</a> code but <a href="https://racket-lang.org">Racket</a> code. As we mentioned, Rosette is a language extension based on Racket.</p> <p>To render the file with your editor, your should search for Racket plugins. Here are the official versions: <a href="https://docs.racket-lang.org/guide/Visual_Studio_Code.html">VScode</a> and <a href="https://docs.racket-lang.org/guide/Sublime_Text.html">Sublime</a>. Vim and Emacs probably support racket out of the box. If not, check: <a href="https://docs.racket-lang.org/guide/Vim.html">Vim</a> and <a href="https://docs.racket-lang.org/guide/Emacs.html">Emacs</a></p> <blockquote class="note-title"> <p><a href="https://docs.racket-lang.org">Racket’s official document page</a> is extremely convenient to search for information about sytax or functions. Just put the function name into the search box at the left-top corner. We will also provide links to this document while going through the code.</p> </blockquote> <h3 id="define-functions-call-functions-and-define-variables"> <a href="#define-functions-call-functions-and-define-variables" class="anchor-heading" aria-labelledby="define-functions-call-functions-and-define-variables"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Define Functions, Call Functions, and Define Variables </h3> <p>Skim through the file, you can see a bunch of functions are defined in a pattern:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">init-impl</span> <span class="nv">imem</span><span class="p">)</span>
  <span class="c1">; STEP1: Initialize a new tiny_cpu whose states are all zeros.</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">tiny_cpu</span> <span class="p">(</span><span class="nf">new-zeroed-tiny_cpu_s</span><span class="p">))</span>
  
  <span class="c1">; STEP2: Pull up the reset signal and advance cpu state to the next cycle.</span>
  <span class="p">(</span><span class="k">set!</span> <span class="nv">tiny_cpu</span> <span class="p">(</span><span class="nf">step</span> <span class="p">(</span><span class="nf">with-input</span> <span class="nv">tiny_cpu</span> <span class="p">(</span><span class="nf">input*</span> <span class="ss">'rst</span> <span class="no">#t</span><span class="p">))))</span>
  
  <span class="o">...</span> <span class="o">...</span>
  
  <span class="c1">; STEP4: Create a impl structure and return it.</span>
  <span class="p">(</span><span class="nf">impl</span> <span class="nv">tiny_cpu</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div> <p>This <a href="https://docs.racket-lang.org/guide/define.html">defines a function</a> named <code class="language-plaintext highlighter-rouge">init-impl</code> which takes one argument named <code class="language-plaintext highlighter-rouge">imem</code>. The last line of the function body <code class="language-plaintext highlighter-rouge">(impl tiny_cpu)</code> is the return value.</p> <p>To call a function, we put brackets around the function name and the argument. For example, <code class="language-plaintext highlighter-rouge">(impl tiny_cpu)</code> calls a function named <code class="language-plaintext highlighter-rouge">impl</code> with argument <code class="language-plaintext highlighter-rouge">tiny_cpu</code>.</p> <p>The variables are defined in a similar way. The first line of the function body above defines a variable named <code class="language-plaintext highlighter-rouge">tiny_cpu</code>, which is the return value of function <code class="language-plaintext highlighter-rouge">new-zeroed-tiny_cpu_s</code> (we will explain the meaning of <code class="language-plaintext highlighter-rouge">new-zeroed-tiny_cpu_s</code> later). Note that in a functional programming language like Racket, people try to avoid updating the value of a variable (for code reusability). However, you can still update its value with <a href="https://docs.racket-lang.org/reference/set_.html#%28form._%28%28quote._~23~25kernel%29._set%21%29%29"><code class="language-plaintext highlighter-rouge">set!</code> function</a>. For example, the code above updates the value of <code class="language-plaintext highlighter-rouge">tiny_cpu</code> to the value returned by <code class="language-plaintext highlighter-rouge">(step (with-input tiny_cpu (input* 'rst #t)))</code> (we will also explain the meaning of <code class="language-plaintext highlighter-rouge">step</code> later). Actually, it is a convention to add <code class="language-plaintext highlighter-rouge">!</code> to the function name if it updates the value of its arguments.</p> <h3 id="include-libraries"> <a href="#include-libraries" class="anchor-heading" aria-labelledby="include-libraries"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Include libraries </h3> <p>The first three lines in the file are the basic information about the whole file. <a href="https://docs.racket-lang.org/guide/hash-lang_syntax.html"><code class="language-plaintext highlighter-rouge">#lang rosette</code></a> states the file use rosette as a base language. <a href="https://docs.racket-lang.org/guide/module-require.html"><code class="language-plaintext highlighter-rouge">(require ...)</code></a> includes (or imports) a few other files. <a href="https://docs.racket-lang.org/guide/module-provide.html"><code class="language-plaintext highlighter-rouge">(provide ...)</code></a> states that if this file is required by another file, that file will have access to use these provided functions and variables.</p> <h3 id="struct"> <a href="#struct" class="anchor-heading" aria-labelledby="struct"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Struct </h3> <p>Same as many other languages, you can define your own data structure in Racket, which enables modular designs. Actually, this whole file is defining functions operating on a <code class="language-plaintext highlighter-rouge">struct</code> named <code class="language-plaintext highlighter-rouge">impl</code>. We use <code class="language-plaintext highlighter-rouge">init-impl</code> to initialize a tiny_cpu implementation, use <code class="language-plaintext highlighter-rouge">step-impl!</code> to simulate the implementation for 1 cycle, and use <code class="language-plaintext highlighter-rouge">impl-commit</code> to indicate whether it will commit an instruction at this cycle. It is a naming convention to have the struct name <code class="language-plaintext highlighter-rouge">impl</code> in the function names and these functions’ first arguments are actually also a variable with <code class="language-plaintext highlighter-rouge">impl</code> type. To understand these functions, the table below summarizes the default APIs to operate on a struct.</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>API</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>Define a new struct</td> <td>(<strong>struct</strong> <em>id</em> (<em>field1</em> <em>field2</em> …))</td> <td>(<strong>struct</strong> <em>impl</em> (<em>tiny_cpu</em>)) defines a new data type named <code class="language-plaintext highlighter-rouge">impl</code>, it has a field named <code class="language-plaintext highlighter-rouge">tiny_cpu</code>.</td> </tr> <tr> <td>Initialize a struct</td> <td>(<strong>id</strong> x1 x2 … )</td> <td>(<strong>impl</strong> (new-zeroed-tiny_cpu_s)) returns a <code class="language-plaintext highlighter-rouge">impl</code> struct whose field is initialized with the return value of function <code class="language-plaintext highlighter-rouge">new-zeroed-tiny_cpu_s</code></td> </tr> <tr> <td>Extract a field</td> <td>(<strong>id-field</strong> INST)</td> <td>(<strong>impl-tiny_cpu</strong> impl) takes an instance named <code class="language-plaintext highlighter-rouge">impl</code> and returns the value saved in its <code class="language-plaintext highlighter-rouge">tiny_cpu</code> field.</td> </tr> <tr> <td>Update a field</td> <td>(<strong>set-id-field!</strong> INST value)</td> <td>(<strong>set-impl-tiny_cpu!</strong> impl (step …)) uses the return value of function <code class="language-plaintext highlighter-rouge">step</code> to update the <code class="language-plaintext highlighter-rouge">tiny_cpu</code> field of instance <code class="language-plaintext highlighter-rouge">impl</code></td> </tr> </tbody> </table></div> <h3 id="bitvector-and-vector"> <a href="#bitvector-and-vector" class="anchor-heading" aria-labelledby="bitvector-and-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Bitvector and vector </h3> <p>When we model and simulate a cpu, most data is in bit or vector of bits formats. To represent these data, we will frequently use bitvector and vector structure in our Racket code. <code class="language-plaintext highlighter-rouge">bitvector</code> is a datatype that saves bits with a fixed width (e.g., 4 bits, 32 bits). It can be used to represent a register or an entry of the memory. <code class="language-plaintext highlighter-rouge">vector</code> is a fixed-length array. It can be used to represent a memory.</p> <p>For example, in the <code class="language-plaintext highlighter-rouge">testMe</code> function in <code class="language-plaintext highlighter-rouge">src/impl.rkt</code>. we call <code class="language-plaintext highlighter-rouge">init-impl</code> function to initialize a tiny_cpu with an imem as the argument. The imem is:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">vector</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">bv</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div> <p>It initializes a 16-element vector and each element is a 4-bit bitvector whose value is either 0 or 1.</p> <p>For more APIs on <a href="https://docs.racket-lang.org/rosette-guide/sec_bitvectors.html#%28def._%28%28lib._rosette%2Fbase%2Fbase..rkt%29._bitvector%29%29">bitvector</a> and <a href="https://docs.racket-lang.org/reference/vectors.html#%28def._%28%28quote._~23~25kernel%29._vector%29%29">vector</a>, the official document is the most helpful resource. We also summarize a few APIs here:</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>API</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>Initialize a bitvector</td> <td>(<strong>bv</strong> value size)</td> <td>(<strong>bv</strong> 1 4) returns a 4-bit bitvector whose value is 1.</td> </tr> <tr> <td>Compare two bitvectors</td> <td>(<strong>bveq</strong> x y)</td> <td>(<strong>bveq</strong> (bv 1 4) (bv 0 4)) returns #f since 1!=0</td> </tr> <tr> <td>Add two bitvectors</td> <td>(<strong>bvadd</strong> x y)</td> <td>(<strong>bveq</strong> (bv 1 4) (bv 15 4)) returns (bv 0 4)</td> </tr> <tr> <td>Concatenate bitvectors</td> <td>(<strong>concat</strong> x1 x2 …)</td> <td>(<strong>concat</strong> (bv 1 4) (bv 0 4)) returns (bv 16 8)</td> </tr> <tr> <td>Initialzie a vector</td> <td>(<strong>vector</strong> v1 v2 …)</td> <td>(<strong>vector</strong> (bv 0 4) (bv 1 4)) returns a 2-element vector</td> </tr> <tr> <td>Extract an element from a vector</td> <td>(<strong>vector-ref</strong> vec pos)</td> <td>(<strong>vector-ref</strong> (vector (bv 0 4) (bv 2 4)) 1) returns (bv 2 4)</td> </tr> <tr> <td>Extract an element from a vector with a bitvector</td> <td>(<strong>vector-ref-bv</strong> vec pos)</td> <td>(<strong>vector-ref</strong> (vector (bv 0 4) (bv 2 4)) (bv 1 4)) returns (bv 2 4)</td> </tr> </tbody> </table></div> <blockquote class="note-title"> <p>Be careful with the difference between <code class="language-plaintext highlighter-rouge">vector-ref</code> and <code class="language-plaintext highlighter-rouge">vector-ref-bv</code>. You might want to use the later one in many cases.</p> </blockquote> <h3 id="printf"> <a href="#printf" class="anchor-heading" aria-labelledby="printf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Printf </h3> <p>Printing is the most basic way to debug a program. Racket provides quite a few different ways to print out a datatype in different formats. We will only use a most simple way:</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>API</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>print out a few variables</td> <td>(<strong>printf</strong> (<strong>~a</strong> x1 x2 …))</td> <td>(<strong>printf</strong> (<strong>~a</strong> “commit: “ (impl-commit impl) “\n”)) prints out something like “commit: #f” and starts a new line.</td> </tr> </tbody> </table></div> <h3 id="branch-and-loops"> <a href="#branch-and-loops" class="anchor-heading" aria-labelledby="branch-and-loops"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Branch and Loops </h3> <p>Here is how to write the simplest control flows in Racket with <a href="https://docs.racket-lang.org/guide/begin.html#%28part._when%2Bunless%29">when</a>, <a href="https://docs.racket-lang.org/guide/conditionals.html#%28part._cond%29">cond (aka, case switch)</a> and <a href="https://docs.racket-lang.org/guide/for.html">for</a>:</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>API</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td>if condition</td> <td>(<strong>when</strong> condition expr1 expr2 …)</td> <td>(when (bveq inst INC) (set! R1 (bvadd R1 (bv 1 4))) (set! R1 (bvadd pc (bv 1 4)))) executes the INC instruction.</td> </tr> <tr> <td>case switch</td> <td>(<strong>cond</strong> [cond1 expr1 expr2 …] [cond2 expr1 …] [else expr1 …])</td> <td>(cond [(bveq inst INC) (set! R1 (bvadd R1 (bv 1 4))) (set! R1 (bvadd pc (bv 1 4)))] [else …]) decodes and executes instructions.</td> </tr> <tr> <td>for loop</td> <td>(<strong>for</strong> ([<em>loopVar</em> (<strong>in-range</strong> loopNum)]) expr1 expr2 …)</td> <td>check the for loop in <code class="language-plaintext highlighter-rouge">testMe</code> function in <code class="language-plaintext highlighter-rouge">src/impl.rkt</code></td> </tr> </tbody> </table></div> <h2 id="hands-on-exercise"> <a href="#hands-on-exercise" class="anchor-heading" aria-labelledby="hands-on-exercise"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Hands-on Exercise </h2> <p>With all the information above, you can start the following exercises!</p> <h3 id="exercise-1-interact-with-tiny-cpu-in-rosette"> <a href="#exercise-1-interact-with-tiny-cpu-in-rosette" class="anchor-heading" aria-labelledby="exercise-1-interact-with-tiny-cpu-in-rosette"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercise 1: Interact With Tiny CPU in Rosette </h3> <p>First, let’s ensure we can run the tiny cpu which was lifted from RTL to Rosette. You can even interact with the CPU and monitor its execution.</p> <!-- In the next subsection, we will read through the file together to get you familiar with Rosette syntax. --> <p>Here is a reference of the APIs provided by <code class="language-plaintext highlighter-rouge">tiny_cpu.rkt</code> and used in <code class="language-plaintext highlighter-rouge">src/impl.rkt</code>:</p> <div class="table-wrapper"><table> <thead> <tr> <th> </th> <th>API</th> <th>Return Value</th> </tr> </thead> <tbody> <tr> <td>Initialization</td> <td>(<strong>new-zeroed-tiny_cpu_s</strong>)</td> <td>a new structure that saves the state of an initialized tiny_cpu (<code class="language-plaintext highlighter-rouge">tiny_cpu_s</code> type)</td> </tr> <tr> <td>Simulation</td> <td>(<strong>step</strong> (<strong>with-input</strong> tiny_cpu (input* ‘rst #t)))</td> <td>a new state of tiny_cpu which is derived by simulating from state <code class="language-plaintext highlighter-rouge">tiny_cpu</code> by 1 cycle with input rst fed with true (you can change <code class="language-plaintext highlighter-rouge">#t</code> to <code class="language-plaintext highlighter-rouge">#f</code> to feed false to rst)</td> </tr> <tr> <td>Extract States</td> <td>(<strong>tiny_cpu_s-REGNAME</strong> tiny_cpu)</td> <td>the value saved in register REGNAME (i.e., R1, R2, pc in our case)</td> </tr> </tbody> </table></div> <blockquote class="exercise-title"> <p>Exercise 1</p> <p>After converting Verilog to Rosette with<code class="language-plaintext highlighter-rouge">./scripts/v2rkt.sh</code>. Isn’t it exciting to be able to simulate a cpu and extract the value of any possible registers at any cycle?</p> <p>Currently, we only print the <code class="language-plaintext highlighter-rouge">commit</code> signal at each cycle. Complete the <code class="language-plaintext highlighter-rouge">print-impl</code> function in <code class="language-plaintext highlighter-rouge">src/impl.rkt</code> to further print the pc, R1, and R2 registers, with the APIs provided in the table above. You can also take <code class="language-plaintext highlighter-rouge">print-impl-imem</code> function as an example.</p> <p>You can test the code with <code class="language-plaintext highlighter-rouge">racket src/impl.rkt</code>. It will run the <code class="language-plaintext highlighter-rouge">testMe</code> function at the end of the file, which simulates the implementation for 20 cycles. With your code, you should see pc, R1, and R2 are printed out at each cycle.</p> </blockquote> <h3 id="exercise-2-encode-specification-into-rosette"> <a href="#exercise-2-encode-specification-into-rosette" class="anchor-heading" aria-labelledby="exercise-2-encode-specification-into-rosette"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercise 2: Encode Specification into Rosette </h3> <p>The yosys+knox toolchain allows us to lift the RTL implementation to Rosette, meaning we have the model that we want to check. We now need to also encode the specification of the processor into Rosette.</p> <p>Specification is basically “what we expect” the hardware to do. Unfortunately, such expectation is usually expressed in human language with unavoidable ambiguity (imagine your boss is asking you to add some fancy features in hardware, it is probably very high-level and misses details). However, to conduct a formal verification, it is very important to express the specification perfectly precisely, because otherwise, Rosette will not know how to check the implementation.</p> <p>In this recitation, we will manually translate the tiny_cpu specification into Rosette. We provide you <code class="language-plaintext highlighter-rouge">src/spec.rkt</code> as a start code. You can execute it with <code class="language-plaintext highlighter-rouge">racket src/spec.rkt</code>. But before you write your part of the code, it does nothing at each cycle.</p> <blockquote class="exercise-title"> <p>Exercise 2</p> <p>Complete the <code class="language-plaintext highlighter-rouge">step-spec!</code> function in <code class="language-plaintext highlighter-rouge">src/spec.rkt</code> to update the tiny_cpu’s state according to the specification figure above. Your specification code should execute 1 instruction at each cycle (while the implementation might take multiple cycles for 1 instruction).</p> <p>Test your code with <code class="language-plaintext highlighter-rouge">racket src/spec.rkt</code>. It will execute the program defined in <code class="language-plaintext highlighter-rouge">testMe</code> at the end of the file for 10 cycles. With your code, you should see, at each cycle, the state is updated properly according to the program.</p> </blockquote> <blockquote class="hint-title"> <p>Bad Syntax Error</p> <p>If you see an error of <code class="language-plaintext highlighter-rouge">let: bad syntax (missing binding pairs or body)</code>, this likely means you left one case of the <code class="language-plaintext highlighter-rouge">cond</code> to be empty, which is not allowed in Racket. You can solve it by adding a dummy line <code class="language-plaintext highlighter-rouge">(void)</code>.</p> </blockquote> <p><strong>How do formal people ensure a precise ISA specification?</strong></p> <p>The ISA manuals are usually hundreds of pages, and it is non-trivial to manually translate them into an executable specification. Researchers working on formal verification always spend a lot of effort translating the manual into a language that is compatible with their verification platform (e.g., Coq, HOL4, and our Rosette). Recently, they made insteresting progress that tries to solve it once and for all.</p> <p>Instead of translating ISA designers’ human language manual, they try to <strong>take control and ask ISA designers to write ISA manual in an executable language from the beginning</strong>! “<a href="https://github.com/riscv/sail-riscv">Sail</a> is a language for describing the instruction-set architecture (ISA) semantics of processors. Sail aims to provide an engineer-friendly, vendor-pseudocode-like language for describing instruction semantics.” From Sail, compilers can generate Latex snippets for documentation, C/Ocaml for executable emulator, Isabelle/HOL4/Coq for formal reasoning.</p> <h3 id="exercise-3-use-assert-to-express-implementation-matches-specification"> <a href="#exercise-3-use-assert-to-express-implementation-matches-specification" class="anchor-heading" aria-labelledby="exercise-3-use-assert-to-express-implementation-matches-specification"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exercise 3: Use <code class="language-plaintext highlighter-rouge">assert</code> to Express “Implementation Matches Specification” </h3> <p>We are almost there! We will now fill in the last piece of our framework, which will compare the execution of the implementation and specification and assert they match. <!-- This might also be a good time to refine our understanding of the framework as below: --></p> <p>What does “match” mean exactly? The implementation of hardware can be far more complicated than the specification. It can take different cycles to finish one instruction, there can be multiple instructions in-flight, and can have different book-keeping structures to remember the execution stages of all in-flight instructions. For a CPU design, all states in the implementation are called <em>micro-architectural states</em> and the states described in the specification only are called <em>architectural states</em>. In order to compare the execution trace from this complicated implementation to the specification, we need to look at the cycle-by-cycle trace of micro-architectural states and extract certain states at certain cycles that can reflect the architectural states.</p> <p>In <code class="language-plaintext highlighter-rouge">src/impl.rkt</code>, we provide a function called <code class="language-plaintext highlighter-rouge">impl-archState</code> to extract those certain states from all micro-architecture states. And provide a function called <code class="language-plaintext highlighter-rouge">impl-commit</code> to indicate at which cycle, the states extracted by <code class="language-plaintext highlighter-rouge">impl-archState</code> should be compared to the architectural state. We use the function <code class="language-plaintext highlighter-rouge">spec-archState</code> in <code class="language-plaintext highlighter-rouge">src/spec.rkt</code> to extract the architectural state from the specification.</p> <p>Those states are <code class="language-plaintext highlighter-rouge">assert</code> to be the same in the <code class="language-plaintext highlighter-rouge">simu</code> function in <code class="language-plaintext highlighter-rouge">src/veri.rkt</code>. Specifically, <code class="language-plaintext highlighter-rouge">src/veri.rkt</code> will simulate the specification and implication with an initial imem containing only symbolic value. The <code class="language-plaintext highlighter-rouge">verify</code> function will ask SMT solver to check all <code class="language-plaintext highlighter-rouge">assert</code> and try to find a concrete instance of the imem that violates some asserts. If SMT provides a counterexample, we query it for the concrete instance of imem and simulate the specification and implication again to demonstrate the assert fails.</p> <blockquote class="exercise-title"> <p>Exercise 3</p> <p>Complete the <code class="language-plaintext highlighter-rouge">impl-archState</code> function in <code class="language-plaintext highlighter-rouge">src/impl.rkt</code> and <code class="language-plaintext highlighter-rouge">spec-archState</code> function in <code class="language-plaintext highlighter-rouge">src/spec.rkt</code>. They extract the architectural state of the implementation and specification.</p> <p>Then, run <code class="language-plaintext highlighter-rouge">racket src/veri.rkt</code> to verify the tiny_cpu. You should see “Counterexample Found” and then the counterexample is simulated and the states of implementation and specification are printed out whenever an instruction is committed. Could you describe the bug found in the implementation?</p> </blockquote> <blockquote class="note-title"> <p>Maybe you want a function to combine multiple bitvector together? Try <code class="language-plaintext highlighter-rouge">concat</code> function mentioned <a href="#bitvector-and-vector">here</a>.</p> </blockquote> <!-- {: .note-title} > You might find your code works with your first try. > But please think: Are the `R1` and `R2` you extracted the state after executing the `pc` you extracted? > The timing behavior can be subtle. --> <p>Congratulations! You have finished our materials on formal verification. Hope you enjoy it.</p> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
